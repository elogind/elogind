# SPDX-License-Identifier: LGPL-2.1+

project('elogind', 'c',
        version : '239',
        license : 'LGPLv2+',
        default_options: [
                'c_std=gnu99',
                'prefix=/usr',
                'sysconfdir=/etc',
                'localstatedir=/var',
        ],
        meson_version : '>= 0.44',
       )

#if 0 /// UNNEEDED by elogind - libudev is external
# libsystemd_version = '0.23.0'
# libudev_version = '1.6.11'
#else
libelogind_version = '0.23.0'
#endif // 0

# We need the same data in two different formats, ugh!
# Also, for hysterical reasons, we use different variable
# names, sometimes. Not all variables are included in every
# set. Ugh, ugh, ugh!
conf = configuration_data()
conf.set_quoted('PACKAGE_STRING',  meson.project_name() + ' ' + meson.project_version())
conf.set_quoted('PACKAGE_VERSION', meson.project_version())

substs = configuration_data()
#if 0 /// Set elogind Package PACKAGE_URL
# substs.set('PACKAGE_URL',          'https://www.freedesktop.org/wiki/Software/systemd')
#else
substs.set('PACKAGE_URL',          'https://github.com/elogind/elogind')
#endif // 0
substs.set('PACKAGE_VERSION',      meson.project_version())

#####################################################################
#if 0 /// elogind does not need this
# 
# # Try to install the git pre-commit hook
# git_hook = run_command(join_paths(meson.source_root(), 'tools/add-git-hook.sh'))
# if git_hook.returncode() == 0
#         message(git_hook.stdout().strip())
# endif
#else
# elogind Note: We use precompiler masks for two reasons:
#               1) The masking is consistent with the sources
#               2) The git patch creator we use for preparing upstream patches
#                  manipulates commits to not take those masks out. Therefore
#                  it can be used to add commits updating the meson files, too.
#endif // 0

#####################################################################

if get_option('split-usr') == 'auto'
        split_usr = run_command('test', '-L', '/bin').returncode() != 0
else
        split_usr = get_option('split-usr') == 'true'
endif
conf.set10('HAVE_SPLIT_USR', split_usr,
           description : '/usr/bin and /bin directories are separate')

if get_option('split-bin') == 'auto'
        split_bin = run_command('test', '-L', '/usr/sbin').returncode() != 0
else
        split_bin = get_option('split-bin') == 'true'
endif
conf.set10('HAVE_SPLIT_BIN', split_bin,
           description : 'bin and sbin directories are separate')

rootprefixdir = get_option('rootprefix')
# Unusual rootprefixdir values are used by some distros
# (see https://github.com/systemd/systemd/pull/7461).
rootprefix_default = split_usr ? '/' : '/usr'
if rootprefixdir == ''
        rootprefixdir = rootprefix_default
endif

#if 0 /// UNNEEDED by elogind
# sysvinit_path = get_option('sysvinit-path')
# sysvrcnd_path = get_option('sysvrcnd-path')
# conf.set10('HAVE_SYSV_COMPAT', sysvinit_path != '' and sysvrcnd_path != '',
#            description : 'SysV init scripts and rcN.d links are supported')
#endif // 0

# join_paths ignore the preceding arguments if an absolute component is
# encountered, so this should canonicalize various paths when they are
# absolute or relative.
prefixdir = get_option('prefix')
if not prefixdir.startswith('/')
        error('Prefix is not absolute: "@0@"'.format(prefixdir))
endif
bindir = join_paths(prefixdir, get_option('bindir'))
libdir = join_paths(prefixdir, get_option('libdir'))
sysconfdir = join_paths(prefixdir, get_option('sysconfdir'))
includedir = join_paths(prefixdir, get_option('includedir'))
datadir = join_paths(prefixdir, get_option('datadir'))
localstatedir = join_paths('/', get_option('localstatedir'))

rootbindir = join_paths(rootprefixdir, 'bin')
rootsbindir = join_paths(rootprefixdir, split_bin ? 'sbin' : 'bin')
#if 0 /// elogind has a different default
# rootlibexecdir = join_paths(rootprefixdir, 'lib/systemd')
#else
rootlibexecdir = get_option('rootlibexecdir')
rootlibexecdir = rootlibexecdir != '' ? rootlibexecdir : join_paths(rootprefixdir, 'lib/elogind')
#endif // 0

rootlibdir = get_option('rootlibdir')
if rootlibdir == ''
        rootlibdir = join_paths(rootprefixdir, libdir.split('/')[-1])
endif

# Dirs of external packages
pkgconfigdatadir = join_paths(datadir, 'pkgconfig')
pkgconfiglibdir = join_paths(libdir, 'pkgconfig')
polkitpolicydir = join_paths(datadir, 'polkit-1/actions')
polkitrulesdir = join_paths(datadir, 'polkit-1/rules.d')
polkitpkladir = join_paths(localstatedir, 'lib/polkit-1/localauthority/10-vendor.d')
varlogdir = join_paths(localstatedir, 'log')
#if 0 /// UNNEEDED by elogind
# xinitrcdir = join_paths(sysconfdir, 'X11/xinit/xinitrc.d')
# rpmmacrosdir = get_option('rpmmacrosdir')
# if rpmmacrosdir != 'no'
#         rpmmacrosdir = join_paths(prefixdir, rpmmacrosdir)
# endif
#endif // 0
modprobedir = join_paths(rootprefixdir, 'lib/modprobe.d')

# Our own paths
#if 0 /// elogind has a bit different layout and does not need all of theses
# pkgdatadir = join_paths(datadir, 'systemd')
# environmentdir = join_paths(prefixdir, 'lib/environment.d')
# pkgsysconfdir = join_paths(sysconfdir, 'systemd')
# userunitdir = join_paths(prefixdir, 'lib/systemd/user')
# userpresetdir = join_paths(prefixdir, 'lib/systemd/user-preset')
# tmpfilesdir = join_paths(prefixdir, 'lib/tmpfiles.d')
# sysusersdir = join_paths(prefixdir, 'lib/sysusers.d')
# sysctldir = join_paths(prefixdir, 'lib/sysctl.d')
# binfmtdir = join_paths(prefixdir, 'lib/binfmt.d')
# modulesloaddir = join_paths(prefixdir, 'lib/modules-load.d')
# networkdir = join_paths(rootprefixdir, 'lib/systemd/network')
# pkgincludedir = join_paths(includedir, 'systemd')
# systemgeneratordir = join_paths(rootlibexecdir, 'system-generators')
# usergeneratordir = join_paths(prefixdir, 'lib/systemd/user-generators')
# systemenvgeneratordir = join_paths(prefixdir, 'lib/systemd/system-environment-generators')
# userenvgeneratordir = join_paths(prefixdir, 'lib/systemd/user-environment-generators')
# systemshutdowndir = join_paths(rootlibexecdir, 'system-shutdown')
# systemsleepdir = join_paths(rootlibexecdir, 'system-sleep')
# systemunitdir = join_paths(rootprefixdir, 'lib/systemd/system')
# systempresetdir = join_paths(rootprefixdir, 'lib/systemd/system-preset')
# udevlibexecdir = join_paths(rootprefixdir, 'lib/udev')
# udevhomedir = udevlibexecdir
# udevrulesdir = join_paths(udevlibexecdir, 'rules.d')
# udevhwdbdir = join_paths(udevlibexecdir, 'hwdb.d')
# catalogdir = join_paths(prefixdir, 'lib/systemd/catalog')
# kernelinstalldir = join_paths(prefixdir, 'lib/kernel/install.d')
# factorydir = join_paths(datadir, 'factory')
# bootlibdir = join_paths(prefixdir, 'lib/systemd/boot/efi')
# testsdir = join_paths(prefixdir, 'lib/systemd/tests')
# systemdstatedir = join_paths(localstatedir, 'lib/systemd')
# catalogstatedir = join_paths(systemdstatedir, 'catalog')
# randomseeddir = join_paths(localstatedir, 'lib/systemd')
# profiledir = join_paths(rootlibexecdir, 'portable', 'profile')
# 
# docdir = get_option('docdir')
# if docdir == ''
#         docdir = join_paths(datadir, 'doc/systemd')
# endif
#else
pkgdatadir = join_paths(datadir, 'elogind')
pkgsysconfdir = join_paths(sysconfdir, 'elogind')
pkgincludedir = join_paths(includedir, 'elogind/systemd')
systemshutdowndir = join_paths(rootlibexecdir, 'system-shutdown')
systemsleepdir = join_paths(rootlibexecdir, 'system-sleep')

# in elogind, udev is external and thus configurable
udevlibexecdir = get_option('udevbindir')
udevlibexecdir = udevlibexecdir != '' ? udevlibexecdir : join_paths(rootprefixdir, 'lib/udev')
udevrulesdir = get_option('udevrulesdir')
udevrulesdir = udevrulesdir != '' ? udevrulesdir : join_paths(udevlibexecdir, 'rules.d')
udevhomedir = udevlibexecdir
factorydir = join_paths(datadir, 'factory')
docdir = get_option('docdir')
docdir = docdir != '' ? docdir: '-'.join([join_paths(datadir, 'doc/elogind'),
                                          meson.project_version()])
testsdir = join_paths(prefixdir, 'lib/elogind/tests')
randomseeddir = join_paths(localstatedir, 'lib/elogind')
#endif // 0

dbuspolicydir = get_option('dbuspolicydir')
if dbuspolicydir == ''
        dbuspolicydir = join_paths(datadir, 'dbus-1/system.d')
endif

dbussessionservicedir = get_option('dbussessionservicedir')
if dbussessionservicedir == ''
        dbussessionservicedir = join_paths(datadir, 'dbus-1/services')
endif

dbussystemservicedir = get_option('dbussystemservicedir')
if dbussystemservicedir == ''
        dbussystemservicedir = join_paths(datadir, 'dbus-1/system-services')
endif

pamlibdir = get_option('pamlibdir')
if pamlibdir == ''
        pamlibdir = join_paths(rootlibdir, 'security')
endif

pamconfdir = get_option('pamconfdir')
if pamconfdir == ''
        pamconfdir = join_paths(sysconfdir, 'pam.d')
endif

#if 0 /// UNNEEDED by elogind
# memory_accounting_default = get_option('memory-accounting-default')
#endif // 0

conf.set_quoted('PKGSYSCONFDIR',                              pkgsysconfdir)
conf.set_quoted('SYSTEM_CONFIG_UNIT_PATH',                    join_paths(pkgsysconfdir, 'system'))
#if 0 /// UNNEEDED by elogind
# conf.set_quoted('SYSTEM_DATA_UNIT_PATH',                      systemunitdir)
# conf.set_quoted('SYSTEM_SYSVINIT_PATH',                       sysvinit_path)
# conf.set_quoted('SYSTEM_SYSVRCND_PATH',                       sysvrcnd_path)
# conf.set_quoted('RC_LOCAL_SCRIPT_PATH_START',                 get_option('rc-local'))
# conf.set_quoted('RC_LOCAL_SCRIPT_PATH_STOP',                  get_option('halt-local'))
# 
# conf.set('ANSI_OK_COLOR',                                     'ANSI_' + get_option('ok-color').underscorify().to_upper())
# 
# conf.set_quoted('USER_CONFIG_UNIT_PATH',                      join_paths(pkgsysconfdir, 'user'))
# conf.set_quoted('USER_DATA_UNIT_PATH',                        userunitdir)
# conf.set_quoted('CERTIFICATE_ROOT',                           get_option('certificate-root'))
# conf.set_quoted('CATALOG_DATABASE',                           join_paths(catalogstatedir, 'database'))
# conf.set_quoted('SYSTEMD_CGROUP_AGENT_PATH',                  join_paths(rootlibexecdir, 'systemd-cgroups-agent'))
# conf.set_quoted('SYSTEMD_BINARY_PATH',                        join_paths(rootlibexecdir, 'systemd'))
# conf.set_quoted('SYSTEMD_FSCK_PATH',                          join_paths(rootlibexecdir, 'systemd-fsck'))
# conf.set_quoted('SYSTEMD_MAKEFS_PATH',                        join_paths(rootlibexecdir, 'systemd-makefs'))
# conf.set_quoted('SYSTEMD_GROWFS_PATH',                        join_paths(rootlibexecdir, 'systemd-growfs'))
# conf.set_quoted('SYSTEMD_SHUTDOWN_BINARY_PATH',               join_paths(rootlibexecdir, 'systemd-shutdown'))
# conf.set_quoted('SYSTEMD_SLEEP_BINARY_PATH',                  join_paths(rootlibexecdir, 'systemd-sleep'))
# conf.set_quoted('SYSTEMCTL_BINARY_PATH',                      join_paths(rootbindir, 'systemctl'))
# conf.set_quoted('SYSTEMD_TTY_ASK_PASSWORD_AGENT_BINARY_PATH', join_paths(rootbindir, 'systemd-tty-ask-password-agent'))
# conf.set_quoted('SYSTEMD_STDIO_BRIDGE_BINARY_PATH',           join_paths(bindir, 'systemd-stdio-bridge'))
#else
conf.set_quoted('SYSTEMD_CGROUP_AGENT_PATH',                  join_paths(rootlibexecdir, 'elogind-cgroups-agent'))
conf.set_quoted('ELOGIND_UACCESS_COMMAND_PATH',               join_paths(rootlibexecdir, 'elogind-uaccess-command'))
conf.set_quoted('SYSTEMD_BINARY_PATH',                        join_paths(rootlibexecdir, 'elogind'))
#endif // 0
conf.set_quoted('ROOTPREFIX',                                 rootprefixdir)
#if 0 /// UNNEEDED by elogind
# conf.set_quoted('RANDOM_SEED_DIR',                            randomseeddir)
# conf.set_quoted('RANDOM_SEED',                                join_paths(randomseeddir, 'random-seed'))
# conf.set_quoted('SYSTEMD_CRYPTSETUP_PATH',                    join_paths(rootlibexecdir, 'systemd-cryptsetup'))
# conf.set_quoted('SYSTEM_GENERATOR_PATH',                      systemgeneratordir)
# conf.set_quoted('USER_GENERATOR_PATH',                        usergeneratordir)
# conf.set_quoted('SYSTEM_ENV_GENERATOR_PATH',                  systemenvgeneratordir)
# conf.set_quoted('USER_ENV_GENERATOR_PATH',                    userenvgeneratordir)
#endif // 0
conf.set_quoted('SYSTEM_SHUTDOWN_PATH',                       systemshutdowndir)
conf.set_quoted('SYSTEM_SLEEP_PATH',                          systemsleepdir)
#if 0 /// UNNEEDED by elogind
# conf.set_quoted('SYSTEMD_KBD_MODEL_MAP',                      join_paths(pkgdatadir, 'kbd-model-map'))
# conf.set_quoted('SYSTEMD_LANGUAGE_FALLBACK_MAP',              join_paths(pkgdatadir, 'language-fallback-map'))
#endif // 0
conf.set_quoted('UDEVLIBEXECDIR',                             udevlibexecdir)
conf.set_quoted('POLKIT_AGENT_BINARY_PATH',                   join_paths(bindir, 'pkttyagent'))
conf.set_quoted('LIBDIR',                                     libdir)
conf.set_quoted('ROOTLIBDIR',                                 rootlibdir)
conf.set_quoted('ROOTLIBEXECDIR',                             rootlibexecdir)
#if 0 /// UNNEEDED by elogind
# conf.set_quoted('BOOTLIBDIR',                                 bootlibdir)
# conf.set_quoted('SYSTEMD_PULL_PATH',                          join_paths(rootlibexecdir, 'systemd-pull'))
# conf.set_quoted('SYSTEMD_IMPORT_PATH',                        join_paths(rootlibexecdir, 'systemd-import'))
# conf.set_quoted('SYSTEMD_EXPORT_PATH',                        join_paths(rootlibexecdir, 'systemd-export'))
# conf.set_quoted('VENDOR_KEYRING_PATH',                        join_paths(rootlibexecdir, 'import-pubring.gpg'))
# conf.set_quoted('USER_KEYRING_PATH',                          join_paths(pkgsysconfdir, 'import-pubring.gpg'))
# conf.set_quoted('DOCUMENT_ROOT',                              join_paths(pkgdatadir, 'gatewayd'))
# conf.set('MEMORY_ACCOUNTING_DEFAULT',                         memory_accounting_default ? 'true' : 'false')
# conf.set_quoted('MEMORY_ACCOUNTING_DEFAULT_YES_NO',           memory_accounting_default ? 'yes' : 'no')
#endif // 0

conf.set_quoted('ABS_BUILD_DIR',                              meson.build_root())
conf.set_quoted('ABS_SRC_DIR',                                meson.source_root())

substs.set('prefix',                                          prefixdir)
substs.set('exec_prefix',                                     prefixdir)
substs.set('libdir',                                          libdir)
substs.set('rootlibdir',                                      rootlibdir)
substs.set('includedir',                                      includedir)
substs.set('pkgsysconfdir',                                   pkgsysconfdir)
substs.set('bindir',                                          bindir)
substs.set('rootbindir',                                      rootbindir)
substs.set('rootlibexecdir',                                  rootlibexecdir)
#if 0 /// UNNEEDED by elogind
# substs.set('systemunitdir',                                   systemunitdir)
# substs.set('userunitdir',                                     userunitdir)
# substs.set('systempresetdir',                                 systempresetdir)
# substs.set('userpresetdir',                                   userpresetdir)
# substs.set('udevhwdbdir',                                     udevhwdbdir)
#endif // 0
substs.set('udevrulesdir',                                    udevrulesdir)
substs.set('udevlibexecdir',                                  udevlibexecdir)
#if 0 /// UNNEEDED by elogind
# substs.set('environmentdir',                                  environmentdir)
# substs.set('catalogdir',                                      catalogdir)
# substs.set('tmpfilesdir',                                     tmpfilesdir)
# substs.set('sysusersdir',                                     sysusersdir)
# substs.set('sysctldir',                                       sysctldir)
# substs.set('binfmtdir',                                       binfmtdir)
# substs.set('modulesloaddir',                                  modulesloaddir)
# substs.set('modprobedir',                                     modprobedir)
# substs.set('systemgeneratordir',                              systemgeneratordir)
# substs.set('usergeneratordir',                                usergeneratordir)
# substs.set('systemenvgeneratordir',                           systemenvgeneratordir)
# substs.set('userenvgeneratordir',                             userenvgeneratordir)
#endif // 0
substs.set('systemshutdowndir',                               systemshutdowndir)
substs.set('systemsleepdir',                                  systemsleepdir)
substs.set('VARLOGDIR',                                       varlogdir)
#if 0 /// UNNEEDED by elogind
# substs.set('CERTIFICATEROOT',                                 get_option('certificate-root'))
# substs.set('SYSTEMCTL',                                       join_paths(rootbindir, 'systemctl'))
# substs.set('RANDOM_SEED',                                     join_paths(randomseeddir, 'random-seed'))
# substs.set('SYSTEM_SYSVINIT_PATH',                            sysvinit_path)
# substs.set('SYSTEM_SYSVRCND_PATH',                            sysvrcnd_path)
# substs.set('RC_LOCAL_SCRIPT_PATH_START',                      get_option('rc-local'))
# substs.set('RC_LOCAL_SCRIPT_PATH_STOP',                       get_option('halt-local'))
# substs.set('MEMORY_ACCOUNTING_DEFAULT',                       memory_accounting_default ? 'yes' : 'no')
#endif // 0

#####################################################################

cc = meson.get_compiler('c')
pkgconfig = import('pkgconfig')
check_compilation_sh = find_program('tools/meson-check-compilation.sh')
meson_build_sh = find_program('tools/meson-build.sh')

if get_option('tests') != 'false'
        cxx = find_program('c++', required : false)
        if cxx.found()
                #  Used only for tests
                add_languages('cpp')
        endif
endif

#if 0 /// elogind does not support fuzz stress testing (, yet).
# want_ossfuzz = get_option('oss-fuzz')
# want_libfuzzer = get_option('llvm-fuzz')
# fuzzer_build = want_ossfuzz or want_libfuzzer
# if want_ossfuzz and want_libfuzzer
#         error('only one of oss-fuzz and llvm-fuzz can be specified')
# endif
# if want_libfuzzer
#         fuzzing_engine = meson.get_compiler('cpp').find_library('Fuzzer')
# endif
# if want_ossfuzz
#         fuzzing_engine = meson.get_compiler('cpp').find_library('FuzzingEngine')
# endif
#else
fuzzer_build = false
#endif // 0

possible_cc_flags = [
        '-Wextra',
        '-Werror=undef',
        '-Wlogical-op',
        '-Wmissing-include-dirs',
        '-Wold-style-definition',
        '-Wpointer-arith',
        '-Winit-self',
        '-Wfloat-equal',
        '-Wsuggest-attribute=noreturn',
        '-Werror=missing-prototypes',
        '-Werror=implicit-function-declaration',
        '-Werror=missing-declarations',
        '-Werror=return-type',
        '-Werror=incompatible-pointer-types',
        '-Werror=format=2',
        '-Wstrict-prototypes',
        '-Wredundant-decls',
        '-Wmissing-noreturn',
        '-Wimplicit-fallthrough=5',
        '-Wshadow',
        '-Wendif-labels',
        '-Wstrict-aliasing=2',
        '-Wwrite-strings',
        '-Werror=overflow',
        '-Werror=shift-count-overflow',
        '-Werror=shift-overflow=2',
        '-Wdate-time',
        '-Wnested-externs',
        '-ffast-math',
        '-fno-common',
        '-fdiagnostics-show-option',
        '-fno-strict-aliasing',
        '-fvisibility=hidden',
        '-fstack-protector',
        '-fstack-protector-strong',
        '--param=ssp-buffer-size=4',
]

# --as-needed and --no-undefined are provided by meson by default,
# run mesonconf to see what is enabled
possible_link_flags = [
        '-Wl,-z,relro',
        '-Wl,-z,now',
]

# the oss-fuzz fuzzers are not built with -fPIE, so don't
# enable it when we are linking against them
if not fuzzer_build
        possible_cc_flags += '-fPIE'
        possible_link_flags += '-pie'
endif

if cc.get_id() == 'clang'
        possible_cc_flags += [
                '-Wno-typedef-redefinition',
                '-Wno-gnu-variable-sized-type-not-at-end',
        ]
endif

if get_option('buildtype') != 'debug'
        possible_cc_flags += [
                '-ffunction-sections',
                '-fdata-sections',
        ]

        possible_link_flags += '-Wl,--gc-sections'
endif

add_project_arguments(cc.get_supported_arguments(possible_cc_flags), language : 'c')

# "negative" arguments: gcc on purpose does not return an error for "-Wno-"
# arguments, just emits a warning. So test for the "positive" version instead.
foreach arg : ['unused-parameter',
               'missing-field-initializers',
               'unused-result',
               'format-signedness',
               'error=nonnull', # work-around for gcc 7.1 turning this on on its own
              ]
        if cc.has_argument('-W' + arg)
                add_project_arguments('-Wno-' + arg, language : 'c')
        endif
endforeach

if cc.compiles('''
   #include <time.h>
   #include <inttypes.h>
   typedef uint64_t usec_t;
   usec_t now(clockid_t clock);
   int main(void) {
           struct timespec now;
           return 0;
   }
''', name : '-Werror=shadow with local shadowing')
        add_project_arguments('-Werror=shadow', language : 'c')
endif

link_test_c = files('tools/meson-link-test.c')

foreach arg : possible_link_flags
        have = run_command(check_compilation_sh,
                           cc.cmd_array(), '-x', 'c', arg,
                           '-include', link_test_c).returncode() == 0
        message('Linking with @0@ supported: @1@'.format(arg, have ? 'yes' : 'no'))
        if have
                add_project_link_arguments(arg, language : 'c')
        endif
endforeach

cpp = ' '.join(cc.cmd_array()) + ' -E'

#####################################################################
# compilation result tests

conf.set('_GNU_SOURCE', true)
conf.set('__SANE_USERSPACE_TYPES__', true)

conf.set('SIZEOF_PID_T', cc.sizeof('pid_t', prefix : '#include <sys/types.h>'))
conf.set('SIZEOF_UID_T', cc.sizeof('uid_t', prefix : '#include <sys/types.h>'))
conf.set('SIZEOF_GID_T', cc.sizeof('gid_t', prefix : '#include <sys/types.h>'))
conf.set('SIZEOF_DEV_T', cc.sizeof('dev_t', prefix : '#include <sys/types.h>'))
conf.set('SIZEOF_INO_T', cc.sizeof('ino_t', prefix : '#include <sys/types.h>'))
conf.set('SIZEOF_TIME_T', cc.sizeof('time_t', prefix : '#include <sys/time.h>'))
conf.set('SIZEOF_RLIM_T', cc.sizeof('rlim_t', prefix : '#include <sys/resource.h>'))

decl_headers = '''
#include <uchar.h>
#include <linux/ethtool.h>
#include <linux/fib_rules.h>
//#include <linux/stat.h>
//#include <sys/stat.h>
'''
# FIXME: key_serial_t is only defined in keyutils.h, this is bound to fail

foreach decl : ['char16_t',
                'char32_t',
                'key_serial_t',
                'struct ethtool_link_settings',
                'struct fib_rule_uid_range',
                'struct statx',
               ]

        # We get -1 if the size cannot be determined
        have = cc.sizeof(decl, prefix : decl_headers) > 0
        conf.set10('HAVE_' + decl.underscorify().to_upper(), have)
endforeach

conf.set10('HAVE_STRUCT_STATX_IN_SYS_STAT_H', cc.sizeof('struct statx', prefix : '''
#include <sys/stat.h>
''', args : '-D_GNU_SOURCE') > 0)
conf.set10('HAVE_STRUCT_STATX_IN_LINUX_STAT_H', cc.sizeof('struct statx', prefix : '''
#include <linux/stat.h>
''', args : '-D_GNU_SOURCE') > 0)

foreach decl : [['IFLA_INET6_ADDR_GEN_MODE',         'linux/if_link.h'],
                ['IN6_ADDR_GEN_MODE_STABLE_PRIVACY', 'linux/if_link.h'],
                ['IFLA_VRF_TABLE',                   'linux/if_link.h'],
                ['IFLA_MACVLAN_FLAGS',               'linux/if_link.h'],
                ['IFLA_IPVLAN_FLAGS',                'linux/if_link.h'],
                ['IFLA_PHYS_PORT_ID',                'linux/if_link.h'],
                ['IFLA_BOND_AD_INFO',                'linux/if_link.h'],
                ['IFLA_VLAN_PROTOCOL',               'linux/if_link.h'],
                ['IFLA_VXLAN_REMCSUM_NOPARTIAL',     'linux/if_link.h'],
                ['IFLA_VXLAN_GPE',                   'linux/if_link.h'],
                ['IFLA_GENEVE_LABEL',                'linux/if_link.h'],
                # if_tunnel.h is buggy and cannot be included on its own
                ['IFLA_VTI_REMOTE',                  'linux/if_tunnel.h', '#include <net/if.h>'],
                ['IFLA_IPTUN_ENCAP_DPORT',           'linux/if_tunnel.h', '#include <net/if.h>'],
                ['IFLA_GRE_ENCAP_DPORT',             'linux/if_tunnel.h', '#include <net/if.h>'],
                ['IFLA_BRIDGE_VLAN_INFO',            'linux/if_bridge.h'],
                ['IFLA_BRPORT_PROXYARP',             'linux/if_link.h'],
                ['IFLA_BRPORT_LEARNING_SYNC',        'linux/if_link.h'],
                ['IFLA_BR_VLAN_DEFAULT_PVID',        'linux/if_link.h'],
                ['IPVLAN_F_PRIVATE',                 'linux/if_link.h'],
                ['NDA_IFINDEX',                      'linux/neighbour.h'],
                ['IFA_FLAGS',                        'linux/if_addr.h'],
                ['FRA_UID_RANGE',                    'linux/fib_rules.h'],
                ['LO_FLAGS_PARTSCAN',                'linux/loop.h'],
                ['VXCAN_INFO_PEER',                  'linux/can/vxcan.h'],
               ]
        prefix = decl.length() > 2 ? decl[2] : ''
        have = cc.has_header_symbol(decl[1], decl[0], prefix : prefix)
        conf.set10('HAVE_' + decl[0], have)
endforeach

foreach ident : ['secure_getenv', '__secure_getenv']
        conf.set10('HAVE_' + ident.to_upper(), cc.has_function(ident))
endforeach

foreach ident : [
        ['memfd_create',      '''#include <sys/mman.h>'''],
        ['gettid',            '''#include <sys/types.h>
                                 #include <unistd.h>'''],
        ['pivot_root',        '''#include <stdlib.h>
                                 #include <unistd.h>'''],     # no known header declares pivot_root
        ['name_to_handle_at', '''#include <sys/types.h>
                                 #include <sys/stat.h>
                                 #include <fcntl.h>'''],
        ['setns',             '''#include <sched.h>'''],
        ['renameat2',         '''#include <stdio.h>
//                                 #include <fcntl.h>'''],
        ['kcmp',              '''#include <linux/kcmp.h>'''],
        ['keyctl',            '''#include <sys/types.h>
                                 #include <keyutils.h>'''],
        ['copy_file_range',   '''#include <sys/syscall.h>
                                 #include <unistd.h>'''],
        ['bpf',               '''#include <sys/syscall.h>
                                 #include <unistd.h>'''],
        ['statx',             '''#include <sys/types.h>
                                 #include <sys/stat.h>
//                                 #include <unistd.h>'''],
        ['explicit_bzero' ,   '''#include <string.h>'''],
        ['reallocarray',      '''#include <malloc.h>'''],
]

        have = cc.has_function(ident[0], prefix : ident[1], args : '-D_GNU_SOURCE')
        conf.set10('HAVE_' + ident[0].to_upper(), have)
endforeach

if cc.has_function('getrandom', prefix : '''#include <sys/random.h>''', args : '-D_GNU_SOURCE')
        conf.set10('USE_SYS_RANDOM_H', true)
        conf.set10('HAVE_GETRANDOM', true)
else
        have = cc.has_function('getrandom', prefix : '''#include <linux/random.h>''')
        conf.set10('USE_SYS_RANDOM_H', false)
        conf.set10('HAVE_GETRANDOM', have)
endif

#####################################################################

sed = find_program('sed')
awk = find_program('awk')
m4 = find_program('m4')
stat = find_program('stat')
git = find_program('git', required : false)
env = find_program('env')
perl = find_program('perl', required : false)

#if 0 /// elogind does not use this but needs a tool to symlink its installed headers.
# meson_make_symlink = meson.source_root() + '/tools/meson-make-symlink.sh'
#else /// Needed by elogind
meson_symlink_headers = meson.source_root() + '/tools/meson-symlink_headers.sh'
#endif // 0
mkdir_p = 'mkdir -p $DESTDIR/@0@'
#if 0 /// unneeded by elogind
# test_efi_create_disk_sh = find_program('test/test-efi-create-disk.sh')
# splash_bmp = files('test/splash.bmp')
#endif // 0

# if -Dxxx-path option is found, use that. Otherwise, check in $PATH,
# /usr/sbin, /sbin, and fall back to the default from middle column.
#if 0 /// elogind has a bit different list and some adaptions
# progs = [['quotaon',    '/usr/sbin/quotaon'    ],
#          ['quotacheck', '/usr/sbin/quotacheck' ],
#          ['kmod',       '/usr/bin/kmod'        ],
#          ['kexec',      '/usr/sbin/kexec'      ],
#          ['sulogin',    '/usr/sbin/sulogin'    ],
#          ['mount',      '/usr/bin/mount',      'MOUNT_PATH'],
#          ['umount',     '/usr/bin/umount',     'UMOUNT_PATH'],
#          ['loadkeys',   '/usr/bin/loadkeys',   'KBD_LOADKEYS'],
#          ['setfont',    '/usr/bin/setfont',    'KBD_SETFONT'],
#         ]
#else
progs = [['halt',       '/sbin/halt',          'HALT'],
         ['kexec',      '/usr/sbin/kexec',     'KEXEC'],
         ['poweroff',   '/sbin/poweroff',      'POWEROFF'],
         ['reboot',     '/sbin/reboot',        'REBOOT'],
        ]
#endif // 0
foreach prog : progs
        path = get_option(prog[0] + '-path')
        if path != ''
                message('Using @1@ for @0@'.format(prog[0], path))
        else
                exe = find_program(prog[0],
                                   '/usr/sbin/' + prog[0],
                                   '/sbin/' + prog[0],
                                   required: false)
                path = exe.found() ? exe.path() : prog[1]
        endif
        name = prog.length() > 2 ? prog[2] : prog[0].to_upper()
        conf.set_quoted(name, path)
        substs.set(name, path)
endforeach

#if 0 /// unneeded by elogind
# conf.set_quoted('TELINIT', get_option('telinit-path'))
# 
# if run_command('ln', '--relative', '--help').returncode() != 0
#         error('ln does not support --relative (added in coreutils 8.16)')
# endif
#endif // 0

############################################################

gperf = find_program('gperf')

gperf_test_format = '''
#include <string.h>
const char * in_word_set(const char *, @0@);
@1@
'''
gperf_snippet_format = 'echo foo,bar | @0@ -L ANSI-C'
gperf_snippet = run_command('sh', '-c', gperf_snippet_format.format(gperf.path()))
gperf_test = gperf_test_format.format('size_t', gperf_snippet.stdout())
if cc.compiles(gperf_test)
        gperf_len_type = 'size_t'
else
        gperf_test = gperf_test_format.format('unsigned', gperf_snippet.stdout())
        if cc.compiles(gperf_test)
                gperf_len_type = 'unsigned'
        else
                error('unable to determine gperf len type')
        endif
endif
message('gperf len type is @0@'.format(gperf_len_type))
conf.set('GPERF_LEN_TYPE', gperf_len_type,
         description : 'The type of gperf "len" parameter')

############################################################

if not cc.has_header('sys/capability.h')
        error('POSIX caps headers not found')
endif
foreach header : ['crypt.h',
                  'linux/btrfs.h',
                  'linux/memfd.h',
                  'linux/vm_sockets.h',
                  'sys/auxv.h',
                  'valgrind/memcheck.h',
                  'valgrind/valgrind.h',
                 ]

        conf.set10('HAVE_' + header.underscorify().to_upper(),
                   cc.has_header(header))
endforeach

############################################################

conf.set_quoted('FALLBACK_HOSTNAME', get_option('fallback-hostname'))
#if 0 /// UNNEEDED by elogind
# conf.set10('ENABLE_COMPAT_GATEWAY_HOSTNAME', get_option('compat-gateway-hostname'))
# gateway_hostnames = ['_gateway'] + (conf.get('ENABLE_COMPAT_GATEWAY_HOSTNAME') == 1 ? ['gateway'] : [])
#endif // 0

default_hierarchy = get_option('default-hierarchy')
conf.set_quoted('DEFAULT_HIERARCHY_NAME', default_hierarchy,
                description : 'default cgroup hierarchy as string')
if default_hierarchy == 'legacy'
        conf.set('DEFAULT_HIERARCHY', 'CGROUP_UNIFIED_NONE')
elif default_hierarchy == 'hybrid'
        conf.set('DEFAULT_HIERARCHY', 'CGROUP_UNIFIED_SYSTEMD')
else
        conf.set('DEFAULT_HIERARCHY', 'CGROUP_UNIFIED_ALL')
endif

#if 0 /// UNNEEDED by elogind
# time_epoch = get_option('time-epoch')
# if time_epoch == ''
#         NEWS = files('NEWS')
#         time_epoch = run_command(stat, '-c', '%Y', NEWS).stdout()
# endif
# time_epoch = time_epoch.to_int()
# conf.set('TIME_EPOCH', time_epoch)
#else
############################################################
# elogind needs to know which cgroups controller to follow.
get_cg_ctrl_sh = find_program('tools/meson-get-cg-controller.sh')
with_cgroupctrl = get_option('cgroup-controller')
if with_cgroupctrl == '' or with_cgroupctrl == 'auto'
        with_cgroupctrl = run_command(get_cg_ctrl_sh, []).stdout().strip()
elif with_cgroupctrl == 'none'
        with_cgroupctrl = 'elogind'
endif

# No controller now is a problem:
if with_cgroupctrl == ''
        error('Unable to determine cgroup controller, but cgroups support is mandatory!')
endif

conf.set_quoted('SYSTEMD_CGROUP_CONTROLLER', '_'.join(['',with_cgroupctrl]),
                description : 'name of the cgroup controller to use')
conf.set_quoted('SYSTEMD_CGROUP_CONTROLLER_LEGACY',
                '='.join(['name', with_cgroupctrl]))
conf.set_quoted('SYSTEMD_CGROUP_CONTROLLER_HYBRID',
                '='.join(['name', with_cgroupctrl]))
############################################################
#endif // 0

system_uid_max = get_option('system-uid-max')
if system_uid_max == ''
        system_uid_max = run_command(
                awk,
                '/^\s*SYS_UID_MAX\s+/ { uid=$2 } END { print uid }',
                '/etc/login.defs').stdout().strip()
        if system_uid_max == ''
                system_uid_max = '999'
        endif
endif
system_uid_max = system_uid_max.to_int()
conf.set('SYSTEM_UID_MAX', system_uid_max)
substs.set('systemuidmax', system_uid_max)
message('maximum system UID is @0@'.format(system_uid_max))

system_gid_max = get_option('system-gid-max')
if system_gid_max == ''
        system_gid_max = run_command(
                awk,
                '/^\s*SYS_GID_MAX\s+/ { gid=$2 } END { print gid }',
                '/etc/login.defs').stdout().strip()
        if system_gid_max == ''
                system_gid_max = '999'
        endif
endif
system_gid_max = system_gid_max.to_int()
conf.set('SYSTEM_GID_MAX', system_gid_max)
substs.set('systemgidmax', system_gid_max)
message('maximum system GID is @0@'.format(system_gid_max))

#if 0 /// UNNEEDED by elogind
# dynamic_uid_min = get_option('dynamic-uid-min').to_int()
# dynamic_uid_max = get_option('dynamic-uid-max').to_int()
# conf.set('DYNAMIC_UID_MIN', dynamic_uid_min)
# conf.set('DYNAMIC_UID_MAX', dynamic_uid_max)
# substs.set('dynamicuidmin', dynamic_uid_min)
# substs.set('dynamicuidmax', dynamic_uid_max)
# 
# container_uid_base_min = get_option('container-uid-base-min').to_int()
# container_uid_base_max = get_option('container-uid-base-max').to_int()
# conf.set('CONTAINER_UID_BASE_MIN', container_uid_base_min)
# conf.set('CONTAINER_UID_BASE_MAX', container_uid_base_max)
# substs.set('containeruidbasemin', container_uid_base_min)
# substs.set('containeruidbasemax', container_uid_base_max)
#endif // 0

nobody_user = get_option('nobody-user')
nobody_group = get_option('nobody-group')

getent_result = run_command('getent', 'passwd', '65534')
if getent_result.returncode() == 0
        name = getent_result.stdout().split(':')[0]
        if name != nobody_user
                warning('\n' +
                        'The local user with the UID 65534 does not match the configured user name "@0@" of the nobody user (its name is @1@).\n'.format(nobody_user, name) +
                        'Your build will result in an user table setup that is incompatible with the local system.')
        endif
endif
id_result = run_command('id', '-u', nobody_user)
if id_result.returncode() == 0
        id = id_result.stdout().to_int()
        if id != 65534
                warning('\n' +
                        'The local user with the configured user name "@0@" of the nobody user does not have UID 65534 (it has @1@).\n'.format(nobody_user, id) +
                        'Your build will result in an user table setup that is incompatible with the local system.')
        endif
endif

getent_result = run_command('getent', 'group', '65534')
if getent_result.returncode() == 0
        name = getent_result.stdout().split(':')[0]
        if name != nobody_group
                warning('\n' +
                        'The local group with the GID 65534 does not match the configured group name "@0@" of the nobody group (its name is @1@).\n'.format(nobody_group, name) +
                        'Your build will result in an group table setup that is incompatible with the local system.')
        endif
endif
id_result = run_command('id', '-g', nobody_group)
if id_result.returncode() == 0
        id = id_result.stdout().to_int()
        if id != 65534
                warning('\n' +
                        'The local group with the configured group name "@0@" of the nobody group does not have UID 65534 (it has @1@).\n'.format(nobody_group, id) +
                        'Your build will result in an group table setup that is incompatible with the local system.')
        endif
endif
if nobody_user != nobody_group and not (nobody_user == 'nobody' and nobody_group == 'nogroup')
        warning('\n' +
                'The configured user name "@0@" and group name "@0@" of the nobody user/group are not equivalent.\n'.format(nobody_user, nobody_group) +
                'Please re-check that both "nobody-user" and "nobody-group" options are correctly set.')
endif

conf.set_quoted('NOBODY_USER_NAME', nobody_user)
conf.set_quoted('NOBODY_GROUP_NAME', nobody_group)
substs.set('NOBODY_USER_NAME', nobody_user)
substs.set('NOBODY_GROUP_NAME', nobody_group)

tty_gid = get_option('tty-gid')
conf.set('TTY_GID', tty_gid)
substs.set('TTY_GID', tty_gid)

#if 0 /// UNNEEDED by elogind
# # Ensure provided GID argument is numeric, otherwise fallback to default assignment
# if get_option('users-gid') != ''
#         users_gid = get_option('users-gid').to_int()
# else
#         users_gid = '-'
# endif
# substs.set('USERS_GID', users_gid)
# 
# conf.set10('ENABLE_ADM_GROUP', get_option('adm-group'))
# conf.set10('ENABLE_WHEEL_GROUP', get_option('wheel-group'))
# 
# substs.set('DEV_KVM_MODE', get_option('dev-kvm-mode'))
# substs.set('GROUP_RENDER_MODE', get_option('group-render-mode'))
#endif // 0

kill_user_processes = get_option('default-kill-user-processes')
conf.set10('KILL_USER_PROCESSES', kill_user_processes)
conf.set_quoted('KILL_USER_PROCESSES_YES_NO', kill_user_processes ? 'yes' : 'no')
substs.set('KILL_USER_PROCESSES', kill_user_processes ? 'yes' : 'no')

#if 0 /// UNNEEDED by elogind
# dns_servers = get_option('dns-servers')
# conf.set_quoted('DNS_SERVERS', dns_servers)
# substs.set('DNS_SERVERS', dns_servers)
# 
# ntp_servers = get_option('ntp-servers')
# conf.set_quoted('NTP_SERVERS', ntp_servers)
# substs.set('NTP_SERVERS', ntp_servers)
#endif // 0

conf.set_quoted('GETTEXT_PACKAGE', meson.project_name())

#if 0 /// UNNEEDED by elogind
# substs.set('SUSHELL', get_option('debug-shell'))
# substs.set('DEBUGTTY', get_option('debug-tty'))
#endif // 0

enable_debug_hashmap = false
enable_debug_mmap_cache = false
#if 1 /// additional elogind debug mode
enable_debug_elogind = false
#endif // 1
foreach name : get_option('debug')
        if name == 'hashmap'
                enable_debug_hashmap = true
        elif name == 'mmap-cache'
                enable_debug_mmap_cache = true
#if 1 /// additional elogind debug mode
        elif name == 'elogind'
                enable_debug_elogind = true
#endif // 1
        else
                message('unknown debug option "@0@", ignoring'.format(name))
        endif
endforeach
conf.set10('ENABLE_DEBUG_HASHMAP', enable_debug_hashmap)
conf.set10('ENABLE_DEBUG_MMAP_CACHE', enable_debug_mmap_cache)
#if 1 /// additional elogind debug mode
conf.set10('ENABLE_DEBUG_ELOGIND', enable_debug_elogind)
#endif // 1

conf.set10('VALGRIND', get_option('valgrind'))

#####################################################################

threads = dependency('threads')
librt = cc.find_library('rt')
libm = cc.find_library('m')
libdl = cc.find_library('dl')
libcrypt = cc.find_library('crypt')

libcap = dependency('libcap', required : false)
if not libcap.found()
        # Compat with Ubuntu 14.04 which ships libcap w/o .pc file
        libcap = cc.find_library('cap')
endif

#if 0 /// UNNEEDED by elogind
# libmount = dependency('mount',
#                       version : fuzzer_build ? '>= 0' : '>= 2.30')
# 
# want_seccomp = get_option('seccomp')
# if want_seccomp != 'false' and not fuzzer_build
#         libseccomp = dependency('libseccomp',
#                                 version : '>= 2.3.1',
#                                 required : want_seccomp == 'true')
#         have = libseccomp.found()
# else
#         have = false
#         libseccomp = []
# endif
#else
libseccomp = []
#endif // 0
conf.set10('HAVE_SECCOMP', have)

want_selinux = get_option('selinux')
if want_selinux != 'false' and not fuzzer_build
        libselinux = dependency('libselinux',
                                version : '>= 2.1.9',
                                required : want_selinux == 'true')
        have = libselinux.found()
else
        have = false
        libselinux = []
endif
conf.set10('HAVE_SELINUX', have)

#if 0 /// UNNEEDED by elogind
# want_apparmor = get_option('apparmor')
# if want_apparmor != 'false' and not fuzzer_build
#         libapparmor = dependency('libapparmor',
#                                  required : want_apparmor == 'true')
#         have = libapparmor.found()
# else
#         have = false
#         libapparmor = []
# endif
#else
libapparmor = []
#endif // 0
conf.set10('HAVE_APPARMOR', have)

smack_run_label = get_option('smack-run-label')
if smack_run_label != ''
        conf.set_quoted('SMACK_RUN_LABEL', smack_run_label)
endif

want_polkit = get_option('polkit')
install_polkit = false
install_polkit_pkla = false
if want_polkit != 'false' and not fuzzer_build
        install_polkit = true

        libpolkit = dependency('polkit-gobject-1',
                               required : false)
        if libpolkit.found() and libpolkit.version().version_compare('< 0.106')
                message('Old polkit detected, will install pkla files')
                install_polkit_pkla = true
        endif
endif
conf.set10('ENABLE_POLKIT', install_polkit)

want_acl = get_option('acl')
if want_acl != 'false' and not fuzzer_build
        libacl = cc.find_library('acl', required : want_acl == 'true')
        have = libacl.found()
else
        have = false
        libacl = []
endif
conf.set10('HAVE_ACL', have)

want_audit = get_option('audit')
if want_audit != 'false' and not fuzzer_build
        libaudit = dependency('audit', required : want_audit == 'true')
        have = libaudit.found()
else
        have = false
        libaudit = []
endif
conf.set10('HAVE_AUDIT', have)

#if 0 /// UNNEEDED by elogind
# want_blkid = get_option('blkid')
# if want_blkid != 'false' and not fuzzer_build
#         libblkid = dependency('blkid', required : want_blkid == 'true')
#         have = libblkid.found()
# else
#         have = false
#         libblkid = []
# endif
# conf.set10('HAVE_BLKID', have)
# 
# want_kmod = get_option('kmod')
# if want_kmod != 'false' and not fuzzer_build
#         libkmod = dependency('libkmod',
#                              version : '>= 15',
#                              required : want_kmod == 'true')
#         have = libkmod.found()
# else
#         have = false
#         libkmod = []
# endif
# conf.set10('HAVE_KMOD', have)
#else
libblkid = []
libkmod = []
#endif // 0

want_pam = get_option('pam')
if want_pam != 'false' and not fuzzer_build
        libpam = cc.find_library('pam', required : want_pam == 'true')
        libpam_misc = cc.find_library('pam_misc', required : want_pam == 'true')
        have = libpam.found() and libpam_misc.found()
else
        have = false
        libpam = []
        libpam_misc = []
endif
conf.set10('HAVE_PAM', have)

#if 0 /// UNNEEDED by elogind
# want_microhttpd = get_option('microhttpd')
# if want_microhttpd != 'false' and not fuzzer_build
#         libmicrohttpd = dependency('libmicrohttpd',
#                                    version : '>= 0.9.33',
#                                    required : want_microhttpd == 'true')
#         have = libmicrohttpd.found()
# else
#         have = false
#         libmicrohttpd = []
# endif
# conf.set10('HAVE_MICROHTTPD', have)
# 
# want_libcryptsetup = get_option('libcryptsetup')
# if want_libcryptsetup != 'false' and not fuzzer_build
#         libcryptsetup = dependency('libcryptsetup',
#                                    version : '>= 1.6.0',
#                                    required : want_libcryptsetup == 'true')
#         have = libcryptsetup.found()
# else
#         have = false
#         libcryptsetup = []
# endif
# conf.set10('HAVE_LIBCRYPTSETUP', have)
# 
# want_libcurl = get_option('libcurl')
# if want_libcurl != 'false' and not fuzzer_build
#         libcurl = dependency('libcurl',
#                              version : '>= 7.32.0',
#                              required : want_libcurl == 'true')
#         have = libcurl.found()
# else
#         have = false
#         libcurl = []
# endif
# conf.set10('HAVE_LIBCURL', have)
# 
# want_libidn = get_option('libidn')
# want_libidn2 = get_option('libidn2')
# if want_libidn == 'true' and want_libidn2 == 'true'
#         error('libidn and libidn2 cannot be requested simultaneously')
# endif
# 
# if want_libidn != 'false' and want_libidn2 != 'true' and not fuzzer_build
#         libidn = dependency('libidn',
#                             required : want_libidn == 'true')
#         have = libidn.found()
# else
#         have = false
#         libidn = []
# endif
# conf.set10('HAVE_LIBIDN', have)
# if not have and want_libidn2 != 'false' and not fuzzer_build
#         # libidn is used for both libidn and libidn2 objects
#         libidn = dependency('libidn2',
#                             required : want_libidn2 == 'true')
#         have = libidn.found()
# else
#         have = false
# endif
# conf.set10('HAVE_LIBIDN2', have)
# 
# want_libiptc = get_option('libiptc')
# if want_libiptc != 'false' and not fuzzer_build
#         libiptc = dependency('libiptc',
#                              required : want_libiptc == 'true')
#         have = libiptc.found()
# else
#         have = false
#         libiptc = []
# endif
# conf.set10('HAVE_LIBIPTC', have)
# 
# want_qrencode = get_option('qrencode')
# if want_qrencode != 'false' and not fuzzer_build
#         libqrencode = dependency('libqrencode',
#                                  required : want_qrencode == 'true')
#         have = libqrencode.found()
# else
#         have = false
#         libqrencode = []
# endif
# conf.set10('HAVE_QRENCODE', have)
# 
# want_gcrypt = get_option('gcrypt')
# if want_gcrypt != 'false' and not fuzzer_build
#         libgcrypt = cc.find_library('gcrypt', required : want_gcrypt == 'true')
#         libgpg_error = cc.find_library('gpg-error', required : want_gcrypt == 'true')
#         have = libgcrypt.found() and libgpg_error.found()
# else
#         have = false
# endif
# if not have
#         # link to neither of the libs if one is not found
#         libgcrypt = []
#         libgpg_error = []
# endif
# conf.set10('HAVE_GCRYPT', have)
# 
# want_gnutls = get_option('gnutls')
# if want_gnutls != 'false' and not fuzzer_build
#         libgnutls = dependency('gnutls',
#                                version : '>= 3.1.4',
#                                required : want_gnutls == 'true')
#         have = libgnutls.found()
# else
#         have = false
#         libgnutls = []
# endif
# conf.set10('HAVE_GNUTLS', have)
# 
# want_elfutils = get_option('elfutils')
# if want_elfutils != 'false' and not fuzzer_build
#         libdw = dependency('libdw',
#                            required : want_elfutils == 'true')
#         have = libdw.found()
# else
#         have = false
#         libdw = []
# endif
# conf.set10('HAVE_ELFUTILS', have)
# 
# want_zlib = get_option('zlib')
# if want_zlib != 'false' and not fuzzer_build
#         libz = dependency('zlib',
#                           required : want_zlib == 'true')
#         have = libz.found()
# else
#         have = false
#         libz = []
# endif
# conf.set10('HAVE_ZLIB', have)
# 
# want_bzip2 = get_option('bzip2')
# if want_bzip2 != 'false' and not fuzzer_build
#         libbzip2 = cc.find_library('bz2',
#                                    required : want_bzip2 == 'true')
#         have = libbzip2.found()
# else
#         have = false
#         libbzip2 = []
# endif
# conf.set10('HAVE_BZIP2', have)
# 
# want_xz = get_option('xz')
# if want_xz != 'false' and not fuzzer_build
#         libxz = dependency('liblzma',
#                            required : want_xz == 'true')
#         have = libxz.found()
# else
#         have = false
#         libxz = []
# endif
# conf.set10('HAVE_XZ', have)
# 
# want_lz4 = get_option('lz4')
# if want_lz4 != 'false' and not fuzzer_build
#         liblz4 = dependency('liblz4',
#                             required : want_lz4 == 'true')
#         have = liblz4.found()
# else
#         have = false
#         liblz4 = []
# endif
# conf.set10('HAVE_LZ4', have)
# 
# want_xkbcommon = get_option('xkbcommon')
# if want_xkbcommon != 'false' and not fuzzer_build
#         libxkbcommon = dependency('xkbcommon',
#                                   version : '>= 0.3.0',
#                                   required : want_xkbcommon == 'true')
#         have = libxkbcommon.found()
# else
#         have = false
#         libxkbcommon = []
# endif
#else
libmicrohttpd = []
libcryptsetup = []
libcurl = []
libidn = []
libiptc = []
libqrencode = []
libgcrypt = []
libgpg_error = []
libgnutls = []
libdw = []
libz = []
libbzip2 = []
libxz = []
liblz4 = []
libxkbcommon = []
#endif // 0
conf.set10('HAVE_XKBCOMMON', have)

want_pcre2 = get_option('pcre2')
if want_pcre2 != 'false'
        libpcre2 = dependency('libpcre2-8',
                              required : want_pcre2 == 'true')
        have = libpcre2.found()
else
        have = false
        libpcre2 = []
endif
conf.set10('HAVE_PCRE2', have)

want_glib = get_option('glib')
if want_glib != 'false' and not fuzzer_build
        libglib =    dependency('glib-2.0',
                                version : '>= 2.22.0',
                                required : want_glib == 'true')
        libgobject = dependency('gobject-2.0',
                                version : '>= 2.22.0',
                                required : want_glib == 'true')
        libgio =     dependency('gio-2.0',
                                required : want_glib == 'true')
        have = libglib.found() and libgobject.found() and libgio.found()
else
        have = false
        libglib = []
        libgobject = []
        libgio = []
endif
conf.set10('HAVE_GLIB', have)

want_dbus = get_option('dbus')
if want_dbus != 'false' and not fuzzer_build
        libdbus = dependency('dbus-1',
                             version : '>= 1.3.2',
                             required : want_dbus == 'true')
        have = libdbus.found()
else
        have = false
        libdbus = []
endif
conf.set10('HAVE_DBUS', have)

#if 0 /// UNNEEDED by elogind
# default_dnssec = get_option('default-dnssec')
# if fuzzer_build
#         default_dnssec = 'no'
# endif
# if default_dnssec != 'no' and conf.get('HAVE_GCRYPT') == 0
#         message('default-dnssec cannot be set to yes or allow-downgrade when gcrypt is disabled. Setting default-dnssec to no.')
#         default_dnssec = 'no'
# endif
# conf.set('DEFAULT_DNSSEC_MODE',
#          'DNSSEC_' + default_dnssec.underscorify().to_upper())
# substs.set('DEFAULT_DNSSEC_MODE', default_dnssec)
# 
# dns_over_tls = get_option('dns-over-tls')
# if dns_over_tls != 'false'
#         have = conf.get('HAVE_GNUTLS') == 1
#         if dns_over_tls == 'true' and not have
#                 error('DNS-over-TLS support was requested, but dependencies are not available')
#         endif
# else
#         have = false
# endif
# conf.set10('ENABLE_DNS_OVER_TLS', have)
# 
# default_dns_over_tls = get_option('default-dns-over-tls')
# if fuzzer_build
#         default_dns_over_tls = 'no'
# endif
# if default_dns_over_tls != 'no' and conf.get('ENABLE_DNS_OVER_TLS') == 0
#         message('default-dns-over-tls cannot be set to opportunistic when DNS-over-TLS support is disabled. Setting default-dns-over-tls to no.')
#         default_dns_over_tls = 'no'
# endif
# conf.set('DEFAULT_DNS_OVER_TLS_MODE',
#          'DNS_OVER_TLS_' + default_dns_over_tls.underscorify().to_upper())
# substs.set('DEFAULT_DNS_OVER_TLS_MODE', default_dns_over_tls)
# 
# want_importd = get_option('importd')
# if want_importd != 'false'
#         have = (conf.get('HAVE_LIBCURL') == 1 and
#                 conf.get('HAVE_ZLIB') == 1 and
#                 conf.get('HAVE_BZIP2') == 1 and
#                 conf.get('HAVE_XZ') == 1 and
#                 conf.get('HAVE_GCRYPT') == 1)
#         if want_importd == 'true' and not have
#                 error('importd support was requested, but dependencies are not available')
#         endif
# else
#         have = false
# endif
# conf.set10('ENABLE_IMPORTD', have)
# 
# want_remote = get_option('remote')
# if want_remote != 'false'
#         have_deps = [conf.get('HAVE_MICROHTTPD') == 1,
#                      conf.get('HAVE_LIBCURL') == 1]
#         # sd-j-remote requires µhttpd, and sd-j-upload requires libcurl, so
#         # it's possible to build one without the other. Complain only if
#         # support was explictly requested. The auxiliary files like sysusers
#         # config should be installed when any of the programs are built.
#         if want_remote == 'true' and not (have_deps[0] and have_deps[1])
#                 error('remote support was requested, but dependencies are not available')
#         endif
#         have = have_deps[0] or have_deps[1]
# else
#         have = false
# endif
#endif // 0
conf.set10('ENABLE_REMOTE', have)

foreach term : ['utmp',
#if 0 /// UNNEEDED by elogind
#                 'hibernate',
#                 'environment-d',
#                 'binfmt',
#                 'coredump',
#                 'resolve',
#                 'logind',
#                 'hostnamed',
#                 'localed',
#                 'machined',
#                 'portabled',
#                 'networkd',
#                 'timedated',
#                 'timesyncd',
#                 'myhostname',
#                 'firstboot',
#                 'randomseed',
#                 'backlight',
#                 'vconsole',
#                 'quotacheck',
#                 'sysusers',
#                 'tmpfiles',
#                 'hwdb',
#                 'rfkill',
#                 'ldconfig',
#                 'efi',
#                 'tpm',
#                 'ima',
#                 'smack',
#                 'gshadow',
#                 'idn',
#                 'nss-systemd']
#else
                'smack']
#endif // 0
        have = get_option(term)
        name = 'ENABLE_' + term.underscorify().to_upper()
        conf.set10(name, have)
endforeach

#if 0 /// UNNEEDED by elogind
# conf.set10('ENABLE_TIMEDATECTL', get_option('timedated') or get_option('timesyncd'))
#endif // 0

want_tests = get_option('tests')
install_tests = get_option('install-tests')
slow_tests = get_option('slow-tests')
tests = []
fuzzers = []

conf.set10('SYSTEMD_SLOW_TESTS_DEFAULT', slow_tests)

#####################################################################

#if 0 /// UNNEEDED by elogind
# if get_option('efi')
#         efi_arch = host_machine.cpu_family()
# 
#         if efi_arch == 'x86'
#                 EFI_MACHINE_TYPE_NAME = 'ia32'
#                 gnu_efi_arch = 'ia32'
#         elif efi_arch == 'x86_64'
#                 EFI_MACHINE_TYPE_NAME = 'x64'
#                 gnu_efi_arch = 'x86_64'
#         elif efi_arch == 'arm'
#                 EFI_MACHINE_TYPE_NAME = 'arm'
#                 gnu_efi_arch = 'arm'
#         elif efi_arch == 'aarch64'
#                 EFI_MACHINE_TYPE_NAME = 'aa64'
#                 gnu_efi_arch = 'aarch64'
#         else
#                 EFI_MACHINE_TYPE_NAME = ''
#                 gnu_efi_arch = ''
#         endif
# 
#         have = true
#         conf.set_quoted('EFI_MACHINE_TYPE_NAME', EFI_MACHINE_TYPE_NAME)
# 
#         conf.set('SD_TPM_PCR', get_option('tpm-pcrindex').to_int())
# else
#         have = false
# endif
#endif // 0
conf.set10('ENABLE_EFI', have)

#####################################################################

#if 1 /// These are not needed by elogind, but meson wants them although they are commented out.
conf.set_quoted('CERTIFICATE_ROOT',                 '/dev/null')
conf.set_quoted('MEMORY_ACCOUNTING_DEFAULT_YES_NO', 'N/A')
conf.set_quoted('MOUNT_PATH',                       '/dev/null')
conf.set_quoted('SYSTEM_ENV_GENERATOR_PATH',        '/dev/null')
conf.set_quoted('SYSTEM_GENERATOR_PATH',            '/dev/null')
conf.set_quoted('UMOUNT_PATH',                      '/dev/null')
conf.set_quoted('USER_ENV_GENERATOR_PATH',          '/dev/null')
conf.set_quoted('USER_GENERATOR_PATH',              '/dev/null')
#####################################################################

#endif // 1

config_h = configure_file(
        output : 'config.h',
        configuration : conf)

meson_apply_m4 = find_program('tools/meson-apply-m4.sh')

includes = include_directories('src/basic',
                               'src/shared',
                               'src/systemd',
#if 0 /// UNNEEDED by elogind
#                                'src/journal',
#                                'src/journal-remote',
#                                'src/nspawn',
#                                'src/resolve',
#                                'src/timesync',
#                                'src/time-wait-sync',
#endif // 0
                               'src/login',
#if 0 /// UNNEEDED by elogind
#                                'src/udev',
#                                'src/libudev',
#endif // 0
                               'src/core',
#if 0 /// elogind has a different list
#                                'src/libsystemd/sd-bus',
#                                'src/libsystemd/sd-device',
#                                'src/libsystemd/sd-hwdb',
#                                'src/libsystemd/sd-id128',
#                                'src/libsystemd/sd-netlink',
#                                'src/libsystemd/sd-network',
#                                'src/libsystemd-network',
#else
                               'src/libelogind/sd-bus',
                               'src/libelogind/sd-id128',
                               'src/sleep',
                               'src/update-utmp',
#endif // 0
                               '.')

add_project_arguments('-include', 'config.h', language : 'c')

subdir('po')
#if 0 /// UNNEEDED by elogind
# subdir('catalog')
#endif // 0
subdir('src/systemd')
subdir('src/basic')
#if 0 /// UNNEEDED by elogind
# subdir('src/libsystemd')
# subdir('src/libsystemd-network')
# subdir('src/journal')
#else
subdir('src/core')
subdir('src/libelogind')
subdir('src/sleep')
subdir('src/update-utmp')
#endif // 0
subdir('src/login')

#if 0 /// UNNEEDED by elogind
# libjournal_core = static_library(
#         'journal-core',
#         libjournal_core_sources,
#         journald_gperf_c,
#         include_directories : includes,
#         install : false)
#endif // 0

libelogind_sym_path = '@0@/@1@'.format(meson.current_source_dir(), libelogind_sym)
libelogind = shared_library(
        'elogind',
        'src/systemd/sd-id128.h', # pick a header file at random to work around old meson bug
        version : libelogind_version,
        include_directories : includes,
        link_args : ['-shared',
                     '-Wl,--version-script=' + libelogind_sym_path],
#if 0 /// elogind does not need gcrypt or libjournal_client, only threads.
#         link_with : [libbasic,
#                      libbasic_gcrypt],
#         link_whole : [libsystemd_static,
#                       libjournal_client],
#         dependencies : [threads,
#                         librt,
#                         libxz,
#                         liblz4],
#         link_depends : libsystemd_sym,
#else
        link_with : [libbasic],
        link_whole : [libelogind_static],
        dependencies : [threads],
        link_depends : libelogind_sym,
#endif // 0
        install : true,
        install_dir : rootlibdir)

static_libelogind = get_option('static-libelogind')
static_libelogind_pic = static_libelogind == 'true' or static_libelogind == 'pic'

install_libelogind_static = static_library(
        'elogind',
        libelogind_sources,
#if 0 /// No journald with elogind (And before you ask: NO!)
#         journal_client_sources,
#endif // 0
        basic_sources,
#if 0 /// No gcrypt with elogind
#         basic_gcrypt_sources,
#endif // 0
        include_directories : includes,
        build_by_default : static_libelogind != 'false',
        install : static_libelogind != 'false',
        install_dir : rootlibdir,
        pic : static_libelogind == 'true' or static_libelogind == 'pic',
        dependencies : [threads,
                        librt,
                        libxz,
                        liblz4,
                        libcap,
                        libblkid,
#if 0 /// libmount isn't built with elogind (and absolutely not needed anyway.)
#                         libmount,
#endif // 0
                        libselinux,
#if 0 /// No grypt with elogind
#                         libgcrypt],
#else
                        ],
#endif // 0
        c_args : libelogind_c_args + (static_libelogind_pic ? [] : ['-fno-PIC']))

############################################################

# binaries that have --help and are intended for use by humans,
# usually, but not always, installed in /bin.
public_programs = []

#if 0 /// UNNEEDED by elogind
# subdir('src/libudev')
#else
# elogind depends on external libudev:
libudev = dependency('libudev', required : true)
#endif // 0
subdir('src/shared')
#if 0 /// UNNEEDED by elogind
# subdir('src/core')
# subdir('src/udev')
# subdir('src/network')
# 
# subdir('src/analyze')
# subdir('src/journal-remote')
# subdir('src/coredump')
# subdir('src/hostname')
# subdir('src/import')
# subdir('src/kernel-install')
# subdir('src/locale')
# subdir('src/machine')
# subdir('src/portable')
# subdir('src/nspawn')
# subdir('src/resolve')
# subdir('src/timedate')
# subdir('src/timesync')
# subdir('src/vconsole')
# subdir('src/boot/efi')
#endif // 0

subdir('src/test')
#if 0 /// UNNEEDED by elogind
# subdir('src/fuzz')
# subdir('rules')
# subdir('test')
#endif // 0

############################################################

# only static linking apart from libdl, to make sure that the
# module is linked to all libraries that it uses.
test_dlopen = executable(
        'test-dlopen',
        test_dlopen_c,
        include_directories : includes,
        link_with : [libbasic],
        dependencies : [libdl])

#if 0 /// UNNEEDED by elogind
# foreach tuple : [['myhostname', 'ENABLE_MYHOSTNAME'],
#                  ['systemd',    'ENABLE_NSS_SYSTEMD'],
#                  ['mymachines', 'ENABLE_MACHINED'],
#                  ['resolve',    'ENABLE_RESOLVE']]
# 
#         condition = tuple[1] == '' or conf.get(tuple[1]) == 1
#         if condition
#                 module = tuple[0]
# 
#                 sym = 'src/nss-@0@/nss-@0@.sym'.format(module)
#                 version_script_arg = join_paths(meson.current_source_dir(), sym)
# 
#                 nss = shared_library(
#                         'nss_' + module,
#                         'src/nss-@0@/nss-@0@.c'.format(module),
#                         version : '2',
#                         include_directories : includes,
#                         # Note that we link NSS modules with '-z nodelete' so that mempools never get orphaned
#                         link_args : ['-Wl,-z,nodelete',
#                                      '-shared',
#                                      '-Wl,--version-script=' + version_script_arg,
#                                      '-Wl,--undefined'],
#                         link_with : [libsystemd_static,
#                                      libbasic],
#                         dependencies : [threads,
#                                         librt],
#                         link_depends : sym,
#                         install : true,
#                         install_dir : rootlibdir)
# 
#                 # We cannot use shared_module because it does not support version suffix.
#                 # Unfortunately shared_library insists on creating the symlink…
#                 meson.add_install_script('sh', '-c',
#                                          'rm $DESTDIR@0@/libnss_@1@.so'
#                                          .format(rootlibdir, module))
# 
#                 test('dlopen-nss_' + module,
#                      test_dlopen,
#                      args : [nss.full_path()]) # path to dlopen must include a slash
#         endif
# endforeach
#endif // 0

############################################################

#if 0 /// UNNEEDED by elogind
# executable('systemd',
#            systemd_sources,
#            include_directories : includes,
#            link_with : [libcore,
#                         libshared],
#            dependencies : [threads,
#                            librt,
#                            libseccomp,
#                            libselinux,
#                            libmount,
#                            libblkid],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# meson.add_install_script(meson_make_symlink,
#                          join_paths(rootlibexecdir, 'systemd'),
#                          join_paths(rootsbindir, 'init'))
# 
# exe = executable('systemd-analyze',
#                  systemd_analyze_sources,
#                  include_directories : includes,
#                  link_with : [libcore,
#                               libshared],
#                  dependencies : [threads,
#                                  librt,
#                                  libseccomp,
#                                  libselinux,
#                                  libmount,
#                                  libblkid],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# executable('systemd-journald',
#            systemd_journald_sources,
#            include_directories : includes,
#            link_with : [libjournal_core,
#                         libshared],
#            dependencies : [threads,
#                            libxz,
#                            liblz4,
#                            libselinux],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# exe = executable('systemd-cat',
#                  systemd_cat_sources,
#                  include_directories : includes,
#                  link_with : [libjournal_core,
#                               libshared],
#                  dependencies : [threads],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# exe = executable('journalctl',
#                  journalctl_sources,
#                  include_directories : includes,
#                  link_with : [libshared],
#                  dependencies : [threads,
#                                  libqrencode,
#                                  libxz,
#                                  liblz4,
#                                  libpcre2],
#                  install_rpath : rootlibexecdir,
#                  install : true,
#                  install_dir : rootbindir)
# public_programs += [exe]
# 
# executable('systemd-getty-generator',
#            'src/getty-generator/getty-generator.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : systemgeneratordir)
# 
# executable('systemd-debug-generator',
#            'src/debug-generator/debug-generator.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : systemgeneratordir)
# 
# executable('systemd-fstab-generator',
#            'src/fstab-generator/fstab-generator.c',
#            'src/core/mount-setup.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : systemgeneratordir)
# 
# if conf.get('ENABLE_ENVIRONMENT_D') == 1
#         executable('30-systemd-environment-d-generator',
#                    'src/environment-d-generator/environment-d-generator.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : userenvgeneratordir)
# 
#         meson.add_install_script(meson_make_symlink,
#                                  join_paths(sysconfdir, 'environment'),
#                                  join_paths(environmentdir, '99-environment.conf'))
# endif
# 
# if conf.get('ENABLE_HIBERNATE') == 1
#         executable('systemd-hibernate-resume-generator',
#                    'src/hibernate-resume/hibernate-resume-generator.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : systemgeneratordir)
# 
#         executable('systemd-hibernate-resume',
#                    'src/hibernate-resume/hibernate-resume.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# endif
# 
# if conf.get('HAVE_BLKID') == 1
#         executable('systemd-gpt-auto-generator',
#                    'src/gpt-auto-generator/gpt-auto-generator.c',
#                    'src/basic/blkid-util.h',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : libblkid,
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : systemgeneratordir)
# 
#         exe = executable('systemd-dissect',
#                          'src/dissect/dissect.c',
#                          include_directories : includes,
#                          link_with : [libshared],
#                          install_rpath : rootlibexecdir,
#                          install : true,
#                          install_dir : rootlibexecdir)
#         public_programs += [exe]
# endif
# 
# if conf.get('ENABLE_RESOLVE') == 1
#         executable('systemd-resolved',
#                    systemd_resolved_sources,
#                    include_directories : includes,
#                    link_with : [libshared,
#                                 libbasic_gcrypt,
#                                 libsystemd_resolve_core],
#                    dependencies : systemd_resolved_dependencies,
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         exe = executable('resolvectl',
#                          resolvectl_sources,
#                          include_directories : includes,
#                          link_with : [libshared,
#                                       libbasic_gcrypt,
#                                       libsystemd_resolve_core],
#                          dependencies : [threads,
#                                          libgpg_error,
#                                          libm,
#                                          libidn],
#                          install_rpath : rootlibexecdir,
#                          install : true)
#         public_programs += [exe]
# 
#         meson.add_install_script(meson_make_symlink,
#                          join_paths(bindir, 'resolvectl'),
#                          join_paths(rootsbindir, 'resolvconf'))
# 
#         meson.add_install_script(meson_make_symlink,
#                          join_paths(bindir, 'resolvectl'),
#                          join_paths(bindir, 'systemd-resolve'))
# endif
# 
# if conf.get('ENABLE_LOGIND') == 1
#         executable('systemd-logind',
#                    systemd_logind_sources,
#                    include_directories : includes,
#                    link_with : [liblogind_core,
#                                 libshared],
#                    dependencies : [threads,
#                                    libacl],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         exe = executable('loginctl',
#                          loginctl_sources,
#                          include_directories : includes,
#                          link_with : [libshared],
#                          dependencies : [threads,
#                                          liblz4,
#                                          libxz],
#                          install_rpath : rootlibexecdir,
#                          install : true,
#                          install_dir : rootbindir)
#         public_programs += [exe]
# 
#         exe = executable('systemd-inhibit',
#                          'src/login/inhibit.c',
#                          include_directories : includes,
#                          link_with : [libshared],
#                          install_rpath : rootlibexecdir,
#                          install : true,
#                          install_dir : rootbindir)
#         public_programs += [exe]
# 
#         if conf.get('HAVE_PAM') == 1
#                 version_script_arg = join_paths(meson.current_source_dir(), pam_systemd_sym)
#                 pam_systemd = shared_library(
#                         'pam_systemd',
#                         pam_systemd_c,
#                         name_prefix : '',
#                         include_directories : includes,
#                         link_args : ['-shared',
#                                      '-Wl,--version-script=' + version_script_arg],
#                         link_with : [libsystemd_static,
#                                      libshared_static],
#                         dependencies : [threads,
#                                         libpam,
#                                         libpam_misc],
#                         link_depends : pam_systemd_sym,
#                         install : true,
#                         install_dir : pamlibdir)
# 
#                 test('dlopen-pam_systemd',
#                      test_dlopen,
#                      args : [pam_systemd.full_path()]) # path to dlopen must include a slash
#         endif
# endif
# 
# executable('systemd-user-runtime-dir',
#            user_runtime_dir_sources,
#            include_directories : includes,
#            link_with : [libshared, liblogind_core],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
#else

executable('elogind',
                elogind_sources,
                include_directories : includes,
                link_with : [liblogind_core,
                             libshared],
                dependencies : [threads,
                                libacl,
                                libudev],
                install_rpath : rootlibexecdir,
                install : true,
                install_dir : rootlibexecdir)

exe = executable('loginctl',
                        loginctl_sources,
                        include_directories : includes,
                        link_with : [libshared],
                        dependencies : [threads,
                                        libudev],
                        install_rpath : rootlibexecdir,
                        install : true,
                        install_dir : rootbindir)
public_programs += [exe]

exe = executable('elogind-inhibit',
                        'src/login/inhibit.c',
                        include_directories : includes,
                        link_with : [libshared],
                        dependencies : [threads],
                        install_rpath : rootlibexecdir,
                        install : true,
                        install_dir : rootbindir)
public_programs += [exe]

if conf.get('HAVE_PAM') == 1
        version_script_arg = join_paths(meson.current_source_dir(), pam_elogind_sym)
        pam_elogind = shared_library(
                'pam_elogind',
                pam_elogind_c,
                name_prefix : '',
                include_directories : includes,
                link_args : ['-shared',
                                '-Wl,--version-script=' + version_script_arg],
                link_with : [libelogind_static,
                             libshared_static],
                dependencies : [threads,
                                libpam,
                                libpam_misc],
                link_depends : pam_elogind_sym,
                install : true,
                install_dir : pamlibdir)

        test('dlopen-pam_elogind',
             test_dlopen,
             args : [pam_elogind.full_path()]) # path to dlopen must include a slash
endif
#endif // 0
#if 0 /// UNNEEDED by elogind
#         executable('systemd-user-sessions',
#                    'src/user-sessions/user-sessions.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# endif
# 
# if conf.get('ENABLE_EFI') == 1 and conf.get('HAVE_BLKID') == 1
#         exe = executable('bootctl',
#                          'src/boot/bootctl.c',
#                          include_directories : includes,
#                          link_with : [libshared],
#                          dependencies : [libblkid],
#                          install_rpath : rootlibexecdir,
#                          install : true)
#         public_programs += [exe]
# endif
# 
# exe = executable('systemd-socket-activate', 'src/activate/activate.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  dependencies : [threads],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# 
# if get_option('link-systemctl-shared')
#         systemctl_link_with = [libshared]
# else
#         systemctl_link_with = [libsystemd_static,
#                                libshared_static,
#                                libjournal_client,
#                                libbasic_gcrypt]
# endif
# 
# exe = executable('systemctl', 'src/systemctl/systemctl.c',
#                  include_directories : includes,
#                  link_with : systemctl_link_with,
#                  dependencies : [threads,
#                                  libcap,
#                                  libselinux,
#                                  libxz,
#                                  liblz4],
#                  install_rpath : rootlibexecdir,
#                  install : true,
#                  install_dir : rootbindir)
# public_programs += [exe]
# 
# if conf.get('ENABLE_PORTABLED') == 1
#         executable('systemd-portabled',
#                    systemd_portabled_sources,
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [threads],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         exe = executable('portablectl', 'src/portable/portablectl.c',
#                          include_directories : includes,
#                          link_with : [libshared],
#                          dependencies : [threads],
#                          install_rpath : rootlibexecdir,
#                          install : true,
#                          install_dir : rootlibexecdir)
#         public_programs += [exe]
# endif
# 
# foreach alias : ['halt', 'poweroff', 'reboot', 'runlevel', 'shutdown', 'telinit']
#         meson.add_install_script(meson_make_symlink,
#                                  join_paths(rootbindir, 'systemctl'),
#                                  join_paths(rootsbindir, alias))
# endforeach
# 
# if conf.get('ENABLE_BACKLIGHT') == 1
#         executable('systemd-backlight',
#                    'src/backlight/backlight.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# endif
# 
# if conf.get('ENABLE_RFKILL') == 1
#         executable('systemd-rfkill',
#                    'src/rfkill/rfkill.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# endif
# 
# executable('systemd-system-update-generator',
#            'src/system-update-generator/system-update-generator.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : systemgeneratordir)
# 
# if conf.get('HAVE_LIBCRYPTSETUP') == 1
#         executable('systemd-cryptsetup',
#                    'src/cryptsetup/cryptsetup.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [libcryptsetup],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         executable('systemd-cryptsetup-generator',
#                    'src/cryptsetup/cryptsetup-generator.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [libcryptsetup],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : systemgeneratordir)
# 
#         executable('systemd-veritysetup',
#                    'src/veritysetup/veritysetup.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [libcryptsetup],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         executable('systemd-veritysetup-generator',
#                    'src/veritysetup/veritysetup-generator.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [libcryptsetup],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : systemgeneratordir)
# endif
# 
# if conf.get('HAVE_SYSV_COMPAT') == 1
#         executable('systemd-sysv-generator',
#                    'src/sysv-generator/sysv-generator.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : systemgeneratordir)
# 
#         executable('systemd-rc-local-generator',
#                    'src/rc-local-generator/rc-local-generator.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : systemgeneratordir)
# endif
# 
# if conf.get('ENABLE_HOSTNAMED') == 1
#         executable('systemd-hostnamed',
#                    'src/hostname/hostnamed.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         exe = executable('hostnamectl',
#                          'src/hostname/hostnamectl.c',
#                          include_directories : includes,
#                          link_with : [libshared],
#                          install_rpath : rootlibexecdir,
#                          install : true)
#         public_programs += [exe]
# endif
# 
# if conf.get('ENABLE_LOCALED') == 1
#         if conf.get('HAVE_XKBCOMMON') == 1
#                 # logind will load libxkbcommon.so dynamically on its own
#                 deps = [libdl]
#         else
#                 deps = []
#         endif
# 
#         executable('systemd-localed',
#                    systemd_localed_sources,
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : deps,
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         exe = executable('localectl',
#                          localectl_sources,
#                          include_directories : includes,
#                          link_with : [libshared],
#                          install_rpath : rootlibexecdir,
#                          install : true)
#         public_programs += [exe]
# endif
# 
# if conf.get('ENABLE_TIMEDATED') == 1
#         executable('systemd-timedated',
#                    'src/timedate/timedated.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# endif
# 
# if conf.get('ENABLE_TIMEDATECTL') == 1
#         exe = executable('timedatectl',
#                          'src/timedate/timedatectl.c',
#                          include_directories : includes,
#                          install_rpath : rootlibexecdir,
#                          link_with : [libshared],
#                          dependencies : [libm],
#                          install : true)
#         public_programs += [exe]
# endif
# 
# if conf.get('ENABLE_TIMESYNCD') == 1
#         executable('systemd-timesyncd',
#                    systemd_timesyncd_sources,
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [threads,
#                                    libm],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         executable('systemd-time-wait-sync',
#                    'src/time-wait-sync/time-wait-sync.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# endif
# 
# if conf.get('ENABLE_MACHINED') == 1
#         executable('systemd-machined',
#                    systemd_machined_sources,
#                    include_directories : includes,
#                    link_with : [libmachine_core,
#                                 libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         exe = executable('machinectl',
#                          'src/machine/machinectl.c',
#                          include_directories : includes,
#                          link_with : [libshared],
#                          dependencies : [threads,
#                                          libxz,
#                                          liblz4],
#                          install_rpath : rootlibexecdir,
#                          install : true,
#                          install_dir : rootbindir)
#         public_programs += [exe]
# endif
# 
# if conf.get('ENABLE_IMPORTD') == 1
#         executable('systemd-importd',
#                    systemd_importd_sources,
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [threads],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         systemd_pull = executable('systemd-pull',
#                                   systemd_pull_sources,
#                                   include_directories : includes,
#                                   link_with : [libshared],
#                                   dependencies : [libcurl,
#                                                   libz,
#                                                   libbzip2,
#                                                   libxz,
#                                                   libgcrypt],
#                                   install_rpath : rootlibexecdir,
#                                   install : true,
#                                   install_dir : rootlibexecdir)
# 
#         systemd_import = executable('systemd-import',
#                                     systemd_import_sources,
#                                     include_directories : includes,
#                                     link_with : [libshared],
#                                     dependencies : [libcurl,
#                                                     libz,
#                                                     libbzip2,
#                                                     libxz],
#                                     install_rpath : rootlibexecdir,
#                                     install : true,
#                                     install_dir : rootlibexecdir)
# 
#         systemd_export = executable('systemd-export',
#                                     systemd_export_sources,
#                                     include_directories : includes,
#                                     link_with : [libshared],
#                                     dependencies : [libcurl,
#                                                     libz,
#                                                     libbzip2,
#                                                     libxz],
#                                     install_rpath : rootlibexecdir,
#                                     install : true,
#                                     install_dir : rootlibexecdir)
#         public_programs += [systemd_pull, systemd_import, systemd_export]
# endif
# 
# if conf.get('ENABLE_REMOTE') == 1 and conf.get('HAVE_LIBCURL') == 1
#         exe = executable('systemd-journal-upload',
#                          systemd_journal_upload_sources,
#                          include_directories : includes,
#                          link_with : [libshared],
#                          dependencies : [threads,
#                                          libcurl,
#                                          libgnutls,
#                                          libxz,
#                                          liblz4],
#                          install_rpath : rootlibexecdir,
#                          install : true,
#                          install_dir : rootlibexecdir)
#         public_programs += [exe]
# endif
# 
# if conf.get('ENABLE_REMOTE') == 1 and conf.get('HAVE_MICROHTTPD') == 1
#         s_j_remote = executable('systemd-journal-remote',
#                                 systemd_journal_remote_sources,
#                                 include_directories : includes,
#                                 link_with : [libshared,
#                                              libsystemd_journal_remote],
#                                 dependencies : [threads,
#                                                 libmicrohttpd,
#                                                 libgnutls,
#                                                 libxz,
#                                                 liblz4],
#                                 install_rpath : rootlibexecdir,
#                                 install : true,
#                                 install_dir : rootlibexecdir)
# 
#         s_j_gatewayd = executable('systemd-journal-gatewayd',
#                                   systemd_journal_gatewayd_sources,
#                                   include_directories : includes,
#                                   link_with : [libshared],
#                                   dependencies : [threads,
#                                                   libmicrohttpd,
#                                                   libgnutls,
#                                                   libxz,
#                                                   liblz4],
#                                   install_rpath : rootlibexecdir,
#                                   install : true,
#                                   install_dir : rootlibexecdir)
#         public_programs += [s_j_remote, s_j_gatewayd]
# endif
# 
# if conf.get('ENABLE_COREDUMP') == 1
#         executable('systemd-coredump',
#                    systemd_coredump_sources,
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [threads,
#                                    libacl,
#                                    libdw,
#                                    libxz,
#                                    liblz4],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         exe = executable('coredumpctl',
#                          coredumpctl_sources,
#                          include_directories : includes,
#                          link_with : [libshared],
#                          dependencies : [threads,
#                                          libxz,
#                                          liblz4],
#                          install_rpath : rootlibexecdir,
#                          install : true)
#         public_programs += [exe]
# endif
# 
# if conf.get('ENABLE_BINFMT') == 1
#         exe = executable('systemd-binfmt',
#                          'src/binfmt/binfmt.c',
#                          include_directories : includes,
#                          link_with : [libshared],
#                          install_rpath : rootlibexecdir,
#                          install : true,
#                          install_dir : rootlibexecdir)
#         public_programs += [exe]
# 
#         meson.add_install_script('sh', '-c',
#                                  mkdir_p.format(binfmtdir))
#         meson.add_install_script('sh', '-c',
#                                  mkdir_p.format(join_paths(sysconfdir, 'binfmt.d')))
# endif
# 
# if conf.get('ENABLE_VCONSOLE') == 1
#         executable('systemd-vconsole-setup',
#                    'src/vconsole/vconsole-setup.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# endif
# 
# if conf.get('ENABLE_RANDOMSEED') == 1
#         executable('systemd-random-seed',
#                    'src/random-seed/random-seed.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# endif
# 
# if conf.get('ENABLE_FIRSTBOOT') == 1
#         executable('systemd-firstboot',
#                    'src/firstboot/firstboot.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [libcrypt],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootbindir)
# endif
# 
# executable('systemd-remount-fs',
#            'src/remount-fs/remount-fs.c',
#            'src/core/mount-setup.c',
#            'src/core/mount-setup.h',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# executable('systemd-machine-id-setup',
#            'src/machine-id-setup/machine-id-setup-main.c',
#            'src/core/machine-id-setup.c',
#            'src/core/machine-id-setup.h',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootbindir)
# 
# executable('systemd-fsck',
#            'src/fsck/fsck.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# executable('elogind-growfs',
#            'src/partition/growfs.c',
#            include_directories : includes,
#            link_with : [libshared],
#            dependencies : [libcryptsetup],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# executable('elogind-makefs',
#            'src/partition/makefs.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# executable('systemd-sleep',
#            'src/sleep/sleep.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# exe = executable('systemd-sysctl',
#                  'src/sysctl/sysctl.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true,
#                  install_dir : rootlibexecdir)
# public_programs += [exe]
# 
# executable('systemd-ac-power',
#            'src/ac-power/ac-power.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# exe = executable('systemd-detect-virt',
#                  'src/detect-virt/detect-virt.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# exe = executable('systemd-delta',
#                  'src/delta/delta.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# exe = executable('systemd-escape',
#                  'src/escape/escape.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true,
#                  install_dir : rootbindir)
# public_programs += [exe]
# 
# exe = executable('systemd-notify',
#                  'src/notify/notify.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true,
#                  install_dir : rootbindir)
# public_programs += [exe]
# 
# executable('systemd-volatile-root',
#            'src/volatile-root/volatile-root.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# executable('systemd-cgroups-agent',
#            'src/cgroups-agent/cgroups-agent.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
#else
executable('elogind-cgroups-agent',
           'src/cgroups-agent/cgroups-agent.c',
           include_directories : includes,
           link_with : [libshared],
           install_rpath : rootlibexecdir,
           install : true,
           install_dir : rootlibexecdir)
#endif // 0

#if 0 /// UNNEEDED by elogind
# exe = executable('systemd-path',
#                  'src/path/path.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# exe = executable('systemd-ask-password',
#                  'src/ask-password/ask-password.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true,
#                  install_dir : rootbindir)
# public_programs += [exe]
# 
# executable('systemd-reply-password',
#            'src/reply-password/reply-password.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# exe = executable('systemd-tty-ask-password-agent',
#                  'src/tty-ask-password-agent/tty-ask-password-agent.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true,
#                  install_dir : rootbindir)
# public_programs += [exe]
# 
# exe = executable('systemd-cgls',
#                  'src/cgls/cgls.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# exe = executable('systemd-cgtop',
#                  'src/cgtop/cgtop.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# executable('systemd-initctl',
#            'src/initctl/initctl.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# exe = executable('systemd-mount',
#                  'src/mount/mount-tool.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# meson.add_install_script(meson_make_symlink,
#                          'systemd-mount', join_paths(bindir, 'systemd-umount'))
# 
# exe = executable('systemd-run',
#                  'src/run/run.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# exe = executable('systemd-stdio-bridge',
#                  'src/stdio-bridge/stdio-bridge.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# exe = executable('busctl',
#                  'src/busctl/busctl.c',
#                  'src/busctl/busctl-introspect.c',
#                  'src/busctl/busctl-introspect.h',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# if conf.get('ENABLE_SYSUSERS') == 1
#         exe = executable('systemd-sysusers',
#                          'src/sysusers/sysusers.c',
#                          include_directories : includes,
#                          link_with : [libshared],
#                          install_rpath : rootlibexecdir,
#                          install : true,
#                          install_dir : rootbindir)
#         public_programs += [exe]
# endif
# 
# if conf.get('ENABLE_TMPFILES') == 1
#         exe = executable('systemd-tmpfiles',
#                          'src/tmpfiles/tmpfiles.c',
#                          include_directories : includes,
#                          link_with : [libshared],
#                          dependencies : [libacl],
#                          install_rpath : rootlibexecdir,
#                          install : true,
#                          install_dir : rootbindir)
#         public_programs += [exe]
# 
#         test('test-systemd-tmpfiles',
#              test_systemd_tmpfiles_py,
#              args : exe.full_path())
#         # https://github.com/mesonbuild/meson/issues/2681
# endif
# 
# if conf.get('ENABLE_HWDB') == 1
#         exe = executable('systemd-hwdb',
#                          'src/hwdb/hwdb.c',
#                          'src/libsystemd/sd-hwdb/hwdb-internal.h',
#                          include_directories : includes,
#                          link_with : [libudev_static],
#                          install_rpath : udev_rpath,
#                          install : true,
#                          install_dir : rootbindir)
#         public_programs += [exe]
# endif
# 
# if conf.get('ENABLE_QUOTACHECK') == 1
#         executable('systemd-quotacheck',
#                    'src/quotacheck/quotacheck.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# endif
# 
# exe = executable('systemd-socket-proxyd',
#                  'src/socket-proxy/socket-proxyd.c',
#                  include_directories : includes,
#                  link_with : [libshared],
#                  dependencies : [threads],
#                  install_rpath : rootlibexecdir,
#                  install : true,
#                  install_dir : rootlibexecdir)
# public_programs += [exe]
# 
# exe = executable('systemd-udevd',
#                  systemd_udevd_sources,
#                  include_directories : includes,
#                  c_args : ['-DLOG_REALM=LOG_REALM_UDEV'],
#                  link_with : [libudev_core,
#                               libsystemd_network,
#                               libudev_static],
#                  dependencies : [threads,
#                                  libkmod,
#                                  libidn,
#                                  libacl,
#                                  libblkid],
#                  install_rpath : udev_rpath,
#                  install : true,
#                  install_dir : rootlibexecdir)
# public_programs += [exe]
# 
# exe = executable('udevadm',
#                  udevadm_sources,
#                  c_args : ['-DLOG_REALM=LOG_REALM_UDEV'],
#                  include_directories : includes,
#                  link_with : [libudev_core,
#                               libsystemd_network,
#                               libudev_static],
#                  dependencies : [threads,
#                                  libkmod,
#                                  libidn,
#                                  libacl,
#                                  libblkid],
#                  install_rpath : udev_rpath,
#                  install : true,
#                  install_dir : rootbindir)
# public_programs += [exe]
# 
# executable('systemd-shutdown',
#            systemd_shutdown_sources,
#            include_directories : includes,
#            link_with : [libshared],
#            dependencies : [libmount],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# executable('systemd-update-done',
#            'src/update-done/update-done.c',
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# executable('systemd-update-utmp',
#            'src/update-utmp/update-utmp.c',
#            include_directories : includes,
#            link_with : [libshared],
#            dependencies : [libaudit],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
# 
# if conf.get('HAVE_KMOD') == 1
#         executable('systemd-modules-load',
#                    'src/modules-load/modules-load.c',
#                    include_directories : includes,
#                    link_with : [libshared],
#                    dependencies : [libkmod],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         meson.add_install_script('sh', '-c',
#                                  mkdir_p.format(modulesloaddir))
#         meson.add_install_script('sh', '-c',
#                                  mkdir_p.format(join_paths(sysconfdir, 'modules-load.d')))
# endif
# 
# exe = executable('systemd-nspawn',
#                  systemd_nspawn_sources,
#                  'src/core/mount-setup.c', # FIXME: use a variable?
#                  'src/core/mount-setup.h',
#                  'src/core/loopback-setup.c',
#                  'src/core/loopback-setup.h',
#                  include_directories : includes,
#                  link_with : [libnspawn_core,
#                               libshared],
#                  dependencies : [libblkid],
#                  install_rpath : rootlibexecdir,
#                  install : true)
# public_programs += [exe]
# 
# if conf.get('ENABLE_NETWORKD') == 1
#         executable('systemd-networkd',
#                    systemd_networkd_sources,
#                    include_directories : includes,
#                    link_with : [libnetworkd_core,
#                                 libsystemd_network,
#                                 libudev_static,
#                                 libshared],
#                    dependencies : [threads],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         executable('systemd-networkd-wait-online',
#                    systemd_networkd_wait_online_sources,
#                    include_directories : includes,
#                    link_with : [libnetworkd_core,
#                                 libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootlibexecdir)
# 
#         exe = executable('networkctl',
#                    networkctl_sources,
#                    include_directories : includes,
#                    link_with : [libsystemd_network,
#                               libshared],
#                    install_rpath : rootlibexecdir,
#                    install : true,
#                    install_dir : rootbindir)
#         public_programs += [exe]
# endif
# 
# executable('systemd-sulogin-shell',
#            ['src/sulogin-shell/sulogin-shell.c'],
#            include_directories : includes,
#            link_with : [libshared],
#            install_rpath : rootlibexecdir,
#            install : true,
#            install_dir : rootlibexecdir)
#else
executable('elogind-uaccess-command',
           'src/uaccess-command/uaccess-command.c',
           include_directories : includes,
           link_with : [liblogind_core,
                        libshared],
           dependencies: [libacl,
                          libudev],
           install_rpath : rootlibexecdir,
           install : true,
           install_dir : rootlibexecdir)
#endif // 0

############################################################

foreach tuple : tests
        sources = tuple[0]
        link_with = tuple[1].length() > 0 ? tuple[1] : [libshared]
        dependencies = tuple[2]
        condition = tuple.length() >= 4 ? tuple[3] : ''
        type = tuple.length() >= 5 ? tuple[4] : ''
        defs = tuple.length() >= 6 ? tuple[5] : []
        incs = tuple.length() >= 7 ? tuple[6] : includes
        timeout = 30

        name = sources[0].split('/')[-1].split('.')[0]
        if type.startswith('timeout=')
                timeout = type.split('=')[1].to_int()
                type = ''
        endif
        if want_tests == 'false'
                message('Not compiling @0@ because tests is set to false'.format(name))
        elif condition == '' or conf.get(condition) == 1
                exe = executable(
                        name,
                        sources,
                        include_directories : incs,
                        link_with : link_with,
                        dependencies : dependencies,
                        c_args : defs,
                        install_rpath : rootlibexecdir,
                        install : install_tests,
                        install_dir : join_paths(testsdir, type))

                if type == 'manual'
                        message('@0@ is a manual test'.format(name))
                elif type == 'unsafe' and want_tests != 'unsafe'
                        message('@0@ is an unsafe test'.format(name))
                else
                        test(name, exe,
                             env : test_env,
                             timeout : timeout)
                endif
        else
                message('Not compiling @0@ because @1@ is not true'.format(name, condition))
        endif
endforeach

#if 0 /// UNNEEDED by elogind
# exe = executable(
#         'test-libsystemd-sym',
#         test_libsystemd_sym_c,
#         include_directories : includes,
#         link_with : [libsystemd],
#         install : install_tests,
#         install_dir : testsdir)
# test('test-libsystemd-sym', exe)
# 
# exe = executable(
#         'test-libsystemd-static-sym',
#         test_libsystemd_sym_c,
#         include_directories : includes,
#         link_with : [install_libsystemd_static],
#         dependencies : [threads], # threads is already included in dependencies on the library,
#                                   # but does not seem to get propagated. Add here as a work-around.
#         build_by_default : static_libsystemd_pic,
#         install : install_tests and static_libsystemd_pic,
#         install_dir : testsdir)
# if static_libsystemd_pic
#         test('test-libsystemd-static-sym', exe)
# endif
# 
# exe = executable(
#         'test-libudev-sym',
#         test_libudev_sym_c,
#         include_directories : includes,
#         c_args : ['-Wno-deprecated-declarations'],
#         link_with : [libudev],
#         install : install_tests,
#         install_dir : testsdir)
# test('test-libudev-sym', exe)
# 
# exe = executable(
#         'test-libudev-static-sym',
#         test_libudev_sym_c,
#         include_directories : includes,
#         c_args : ['-Wno-deprecated-declarations'],
#         link_with : [install_libudev_static],
#         build_by_default : static_libudev_pic,
#         install : install_tests and static_libudev_pic,
#         install_dir : testsdir)
# if static_libudev_pic
#         test('test-libudev-static-sym', exe)
# endif
# 
# ############################################################
# 
# fuzzer_exes = []
# 
# foreach tuple : fuzzers
#         sources = tuple[0]
#         link_with = tuple[1].length() > 0 ? tuple[1] : [libshared]
#         dependencies = tuple[2]
#         defs = tuple.length() >= 4 ? tuple[3] : []
#         incs = tuple.length() >= 5 ? tuple[4] : includes
# 
#         if fuzzer_build
#                 dependencies += fuzzing_engine
#         else
#                 sources += 'src/fuzz/fuzz-main.c'
#         endif
# 
#         name = sources[0].split('/')[-1].split('.')[0]
# 
#         fuzzer_exes += executable(
#                 name,
#                 sources,
#                 include_directories : [incs, include_directories('src/fuzz')],
#                 link_with : link_with,
#                 dependencies : dependencies,
#                 c_args : defs,
#                 install : false)
# endforeach
# 
# run_target('fuzzers',
#         depends : fuzzer_exes,
#         command : ['true'])
# 
# ############################################################
# 
#else
test_libelogind_sym = executable(
        'test-libelogind-sym',
        test_libelogind_sym_c,
        include_directories : includes,
        link_with : [libelogind],
        install : install_tests,
        install_dir : testsdir)
test('test-libelogind-sym',
     test_libelogind_sym)
#endif // 0
make_directive_index_py = find_program('tools/make-directive-index.py')
make_man_index_py = find_program('tools/make-man-index.py')
xml_helper_py = find_program('tools/xml_helper.py')
#if 0 /// UNNEEDED by elogind
# hwdb_update_sh = find_program('tools/meson-hwdb-update.sh')
# 
# subdir('units')
# subdir('sysctl.d')
# subdir('sysusers.d')
# subdir('tmpfiles.d')
# subdir('presets')
# subdir('hwdb')
# subdir('network')
#endif // 0
subdir('man')
subdir('shell-completion/bash')
subdir('shell-completion/zsh')
#if 0 /// UNNEEDED by elogind
# subdir('doc/sysvinit')
# subdir('doc/var-log')
#endif // 0

# FIXME: figure out if the warning is true:
# https://github.com/mesonbuild/meson/wiki/Reference-manual#install_subdir
install_subdir('factory/etc',
               install_dir : factorydir)


#if 0 /// UNNEEDED by elogind
# install_data('xorg/50-systemd-user.sh',
#              install_dir : xinitrcdir)
# install_data('modprobe.d/systemd.conf',
#              install_dir : modprobedir)
#endif // 0
install_data('LICENSE.GPL2',
             'LICENSE.LGPL2.1',
             'NEWS',
             'README',
             'doc/CODING_STYLE',
#if 0 /// irrelevant for elogind
#              'doc/DISTRO_PORTING',
#              'doc/ENVIRONMENT.md',
#              'doc/HACKING',
#              'doc/TRANSIENT-SETTINGS.md',
#              'doc/TRANSLATORS',
#              'doc/UIDS-GIDS.md',
#endif // 0
             'src/libelogind/sd-bus/GVARIANT-SERIALIZATION',
             install_dir : docdir)

#if 0 /// UNNEEDED by elogind
# meson.add_install_script('sh', '-c', mkdir_p.format(systemdstatedir))
#endif // 0
meson.add_install_script('sh', '-c', 'touch $DESTDIR@0@'.format(prefixdir))

############################################################

meson_check_help = find_program('tools/meson-check-help.sh')

foreach exec : public_programs
        name = exec.full_path().split('/')[-1]
        test('check-help-' + name,
             meson_check_help,
             args : [exec.full_path()])
endforeach

############################################################

#if 0 /// fuzz regression tests are not supported by elogind
# # Enable tests for all supported sanitizers
# foreach tuple : sanitizers
#         sanitizer = tuple[0]
#         build = tuple[1]
# 
#         have = run_command(check_compilation_sh,
#                            cc.cmd_array(), '-x', 'c',
#                            '-fsanitize=@0@'.format(sanitizer),
#                            '-include', link_test_c).returncode() == 0
#         message('@0@ sanitizer supported: @1@'.format(sanitizer, have ? 'yes' : 'no'))
# 
#         if have
#                 prev = ''
#                 foreach p : fuzz_regression_tests
#                         b = p.split('/')[-2]
#                         c = p.split('/')[-1]
# 
#                         name = '@0@:@1@'.format(b, sanitizer)
# 
#                         if name != prev
#                                 if want_tests == 'false'
#                                         message('Not compiling @0@ because tests is set to false'.format(name))
#                                 elif slow_tests
#                                         exe = custom_target(
#                                                 name,
#                                                 output : name,
#                                                 depends : build,
#                                                 command : [env, 'ln', '-fs',
#                                                            join_paths(build.full_path(), b),
#                                                            '@OUTPUT@'],
#                                                 build_by_default : true)
#                                 else
#                                         message('Not compiling @0@ because slow-tests is set to false'.format(name))
#                                 endif
#                         endif
#                         prev = name
# 
#                         if want_tests != 'false' and slow_tests
#                                 test('@0@:@1@:@2@'.format(b, c, sanitizer),
#                                      env,
#                                      args : [exe.full_path(),
#                                              join_paths(meson.source_root(),
#                                                         'test/fuzz-regressions',
#                                                         p)])
#                         endif
#                 endforeach
#         endif
# endforeach
#endif // 0


############################################################

if git.found()
        all_files = run_command(
                git,
                ['--git-dir=@0@/.git'.format(meson.current_source_dir()),
                 'ls-files',
                 ':/*.[ch]'])
        all_files = files(all_files.stdout().split())

        custom_target(
                'tags',
                output : 'tags',
                command : [env, 'etags', '-o', '@0@/TAGS'.format(meson.current_source_dir())] + all_files)
        run_target(
                'ctags',
                command : [env, 'ctags', '-o', '@0@/tags'.format(meson.current_source_dir())] + all_files)
endif

#if 0 /// UNNEEDED by elogind
# if git.found()
#         meson_git_contrib_sh = find_program('tools/meson-git-contrib.sh')
#         run_target(
#                 'git-contrib',
#                 command : [meson_git_contrib_sh])
# endif
#endif // 0

if git.found()
        git_head = run_command(
                git,
                ['--git-dir=@0@/.git'.format(meson.current_source_dir()),
                 'rev-parse', 'HEAD']).stdout().strip()
        git_head_short = run_command(
                git,
                ['--git-dir=@0@/.git'.format(meson.current_source_dir()),
                 'rev-parse', '--short=7', 'HEAD']).stdout().strip()

        run_target(
                'git-snapshot',
                command : ['git', 'archive',
                           '-o', '@0@/systemd-@1@.tar.gz'.format(meson.current_source_dir(),
                                                                 git_head_short),
                           '--prefix', 'systemd-@0@/'.format(git_head),
                           'HEAD'])
endif

############################################################

meson_check_api_docs_sh = find_program('tools/meson-check-api-docs.sh')
run_target(
        'check-api-docs',
#if 0 /// libudev is external, elogind does not need to document it.
#         depends : [man, libsystemd, libudev],
#         command : [meson_check_api_docs_sh, libsystemd.full_path(), libudev.full_path()])
#else
        depends : [man, libelogind],
        command : [meson_check_api_docs_sh, libelogind.full_path()])
#endif // 0

############################################################

status = [
        '@0@ @1@'.format(meson.project_name(), meson.project_version()),

        'split /usr:                        @0@'.format(split_usr),
        'split bin-sbin:                    @0@'.format(split_bin),
        'prefix directory:                  @0@'.format(prefixdir),
        'rootprefix directory:              @0@'.format(rootprefixdir),
        'sysconf directory:                 @0@'.format(sysconfdir),
        'include directory:                 @0@'.format(includedir),
        'lib directory:                     @0@'.format(libdir),
        'rootlib directory:                 @0@'.format(rootlibdir),
#if 1 /// Needed by elogind
        'rootexeclib dir:                   @0@'.format(rootlibexecdir),
#endif // 1
#if 0 /// UNNEEDED by elogind
#        'SysV init scripts:                 @0@'.format(sysvinit_path),
#        'SysV rc?.d directories:            @0@'.format(sysvrcnd_path),
#endif // 0
        'PAM modules directory:             @0@'.format(pamlibdir),
        'PAM configuration directory:       @0@'.format(pamconfdir),
#if 0 /// UNNEEDED by elogind
#        'RPM macros directory:              @0@'.format(rpmmacrosdir),
#endif // 0
        'modprobe.d directory:              @0@'.format(modprobedir),
        'D-Bus policy directory:            @0@'.format(dbuspolicydir),
        'D-Bus session directory:           @0@'.format(dbussessionservicedir),
        'D-Bus system directory:            @0@'.format(dbussystemservicedir),
        'bash completions directory:        @0@'.format(bashcompletiondir),
        'zsh completions directory:         @0@'.format(zshcompletiondir),
#if 0 /// UNSUPPORTED by elogind
#         'extra start script:                @0@'.format(get_option('rc-local')),
#         'extra stop script:                 @0@'.format(get_option('halt-local')),
#         'debug shell:                       @0@ @ @1@'.format(get_option('debug-shell'),
#                                                               get_option('debug-tty')),
#endif // 0
        'TTY GID:                           @0@'.format(tty_gid),
#if 0 /// UNSUPPORTED by elogind
#         'users GID:                         @0@'.format(users_gid),
#endif // 0
        'maximum system UID:                @0@'.format(system_uid_max),
        'maximum system GID:                @0@'.format(system_gid_max),
#if 0 /// UNSUPPORTED by elogind
#         'minimum dynamic UID:               @0@'.format(dynamic_uid_min),
#         'maximum dynamic UID:               @0@'.format(dynamic_uid_max),
#         'minimum container UID base:        @0@'.format(container_uid_base_min),
#         'maximum container UID base:        @0@'.format(container_uid_base_max),
#         '/dev/kvm access mode:              @0@'.format(get_option('dev-kvm-mode')),
#         'render group access mode:          @0@'.format(get_option('group-render-mode')),
#         'certificate root directory:        @0@'.format(get_option('certificate-root')),
#         'support URL:                       @0@'.format(support_url),
#endif // 0
        'nobody user name:                  @0@'.format(nobody_user),
        'nobody group name:                 @0@'.format(nobody_group),
#if 0 /// UNSUPPORTED by elogind
#         'fallback hostname:                 @0@'.format(get_option('fallback-hostname')),
#         'symbolic gateway hostnames:        @0@'.format(', '.join(gateway_hostnames)),
# 
#         'default DNSSEC mode:               @0@'.format(default_dnssec),
#         'default DNS-over-TLS mode:         @0@'.format(default_dns_over_tls),
#         'default cgroup hierarchy:          @0@'.format(default_hierarchy),
#endif // 0
        'default KillUserProcesses setting: @0@'.format(kill_user_processes)]

#if 0 /// UNSUPPORTED by elogind
# alt_dns_servers = '\n                                            '.join(dns_servers.split(' '))
# alt_ntp_servers = '\n                                            '.join(ntp_servers.split(' '))
# status += [
#         'default DNS servers:               @0@'.format(alt_dns_servers),
#         'default NTP servers:               @0@'.format(alt_ntp_servers)]
# 
# alt_time_epoch = run_command('date', '-Is', '-u', '-d',
#                              '@@0@'.format(time_epoch)).stdout().strip()
# status += [
#         'time epoch:                        @0@ (@1@)'.format(time_epoch, alt_time_epoch)]
#endif // 0

# TODO:
# CFLAGS:   ${OUR_CFLAGS} ${CFLAGS}
# CPPFLAGS: ${OUR_CPPFLAGS} ${CPPFLAGS}
# LDFLAGS:  ${OUR_LDFLAGS} ${LDFLAGS}

#if 0 /// UNNEEDED by elogind
# if conf.get('ENABLE_EFI') == 1
#         status += [
#                 'efi arch:                          @0@'.format(efi_arch)]
# 
#         if have_gnu_efi
#                 status += [
#                         'EFI machine type:                  @0@'.format(EFI_MACHINE_TYPE_NAME),
#                         'EFI CC                             @0@'.format(efi_cc),
#                         'EFI lib directory:                 @0@'.format(efi_libdir),
#                         'EFI lds directory:                 @0@'.format(efi_ldsdir),
#                         'EFI include directory:             @0@'.format(efi_incdir)]
#         endif
# endif
#endif // 0

found = []
missing = []

foreach tuple : [
#if 0 /// UNNEEDED by elogind
#         ['libcryptsetup'],
#endif // 0
        ['PAM'],
        ['AUDIT'],
#if 0 /// UNNEEDED by elogind
#         ['IMA'],
#         ['AppArmor'],
#endif // 0
        ['SELinux'],
#if 0 /// UNNEEDED by elogind
#         ['SECCOMP'],
#endif // 0
        ['SMACK'],
#if 0 /// UNNEEDED by elogind
#         ['zlib'],
#         ['xz'],
#         ['lz4'],
#         ['bzip2'],
#endif // 0
        ['ACL'],
#if 0 /// UNNEEDED by elogind
#         ['gcrypt'],
#         ['qrencode'],
#         ['microhttpd'],
#         ['gnutls'],
#         ['libcurl'],
#         ['idn'],
#         ['libidn2'],
#         ['libidn'],
#         ['nss-systemd'],
#         ['libiptc'],
#         ['elfutils'],
#         ['binfmt'],
#         ['vconsole'],
#         ['quotacheck'],
#         ['tmpfiles'],
#         ['environment.d'],
#         ['sysusers'],
#         ['firstboot'],
#         ['randomseed'],
#         ['backlight'],
#         ['rfkill'],
#         ['logind'],
#         ['machined'],
#         ['portabled'],
#         ['importd'],
#         ['hostnamed'],
#         ['timedated'],
#         ['timesyncd'],
#         ['localed'],
#         ['networkd'],
#         ['resolve'],
#         ['DNS-over-TLS'],
#         ['coredump'],
#endif // 0
        ['polkit'],
        ['legacy pkla',      install_polkit_pkla],
#if 0 /// UNNEEDED by elogind
#         ['efi'],
#         ['gnu-efi',          have_gnu_efi],
#         ['kmod'],
#         ['xkbcommon'],
#         ['pcre2'],
#         ['blkid'],
#endif // 0
        ['dbus'],
        ['glib'],
#if 0 /// UNNEEDED by elogind
#         ['nss-myhostname',   conf.get('ENABLE_MYHOSTNAME') == 1],
#         ['hwdb'],
#         ['tpm'],
#endif // 0
        ['man pages',        want_man],
        ['html pages',       want_html],
        ['man page indices', want_man and have_lxml],
#if 0 /// UNNEEDED by elogind
#         ['SysV compat'],
#endif // 0
        ['utmp'],
#if 0 /// UNNEEDED by elogind
#         ['ldconfig'],
#         ['hibernate'],
#         ['adm group',        get_option('adm-group')],
#         ['wheel group',      get_option('wheel-group')],
#         ['gshadow'],
#endif // 0
        ['valgrind',         conf.get('VALGRIND') == 1],
#if 1 /// Extra debugging for elogind
        ['debug elogind'],
#endif // 1
        ['debug hashmap'],
        ['debug mmap cache'],
]

        if tuple.length() >= 2
                cond = tuple[1]
        else
                ident1 = 'HAVE_' + tuple[0].underscorify().to_upper()
                ident2 = 'ENABLE_' + tuple[0].underscorify().to_upper()
                cond = conf.get(ident1, 0) == 1 or conf.get(ident2, 0) == 1
        endif
        if cond
                found += [tuple[0]]
        else
                missing += [tuple[0]]
        endif
endforeach

status += [
        '',
        'enabled features: @0@'.format(', '.join(found)),
        '',
        'disabled features: @0@'.format(', '.join(missing)),
        '']
message('\n         '.join(status))

#if 0 /// Nicely enough this isn't true for elogind. :-)
# if rootprefixdir != rootprefix_default
#         warning('\n' +
#                 'Note that the installation prefix was changed to "@0@".\n'.format(rootprefixdir) +
#                 'systemd used fixed names for unit file directories and other paths, so anything\n' +
#                 'except the default ("@0@") is strongly discouraged.'.format(rootprefix_default))
# endif
#endif // 0
